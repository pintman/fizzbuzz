#+TITLE: FizzBuzz Katas

FizzBuzz ist ein Zählspiel, bei dem die Zahlen bis 100 aufgezählt
werden. Ist die Zahl durch 3 teilbar, wird "fizz" gesagt. Ist sie
durch 5 teilbar, wird "buzz" gesagt. Ist sie durch 3 und 5 teilbar,
wird "fizzbuzz" gesagt. Ansonsten wird die Zahl selbst gesagt.

Wir versuchen uns auf dem Blatt mit einer Aufwärmübung (Kata). Die
anschließenden Übungen lösen alle dasselbe fizzbuzz-Problem, nutzen
jedoch ganz unterschiedliche Herangehensweisen oder Technologien.

* Auf Papier

#+BEGIN_EXAMPLE
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+END_EXAMPLE

* Mit einer Methode
Hier ist eine erste einfache Variante.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  def fizzbuzz_methode(n):
      for i in range(n):
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)

  fizzbuzz_methode(20)
#+END_SRC

#+RESULTS[e51bb9a5c49b0fe5fdecdab0c7f63ffb9ef872c6]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

Das nächste Beispiel wandelt die obige Variante ab, erzeugt aber
dieselbe Ausgabe.

#+BEGIN_SRC python -n :results output :cache yes
  def fizzbuzz_methode2(n):
      for i in range(n):
          s = ""

          if i % 3 == 0:
              s = "fizz"
          if i % 5 == 0:
              s += "buzz"
          if len(s) == 0:
              s = i

          print(s)

  fizzbuzz_methode2(20)

#+END_SRC

#+RESULTS[4f2fef1880aab0b123a0d085f92e4650943accfa]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Ohne Verwendung einer Schleife (rekursiv)

#+BEGIN_SRC python -n :results output

  def fizzbuzz_rekursiv(i):
      if i == 0:
          return
      else:
          fizzbuzz_rekursiv(i-1)

          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)


  fizzbuzz_rekursiv(20)
#+END_SRC

#+RESULTS:
#+begin_example
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
buzz
#+end_example

* Mit Hilfe von nebenläufigen Threads

#+BEGIN_SRC python -n :results output
import threading

def fizzbuzz_thread(i):
    if i % 3 == 0 and i % 5 == 0:
        print("fizzbuzz")
    elif i % 3 == 0:
        print("fizz")
    elif i % 5 == 0:
        print("buzz")
    else:
        print(i)

def fizzbuzz_threading():
    for i in range(20):
        th = threading.Thread(target=fizzbuzz_thread, args=(i,))
        th.start()
        # Wait for thread to finish
        while th.isAlive():
            pass

fizzbuzz_threading()
#+END_SRC

#+RESULTS:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Mit einer anderen IDE

Mögliche Kandidaten wären:

- IDLE
- PyCharm
- Emacs
- vim
- Atom

* In einer anderen Programmiersprache

Mögliche Sprachen wären:

- Java
- Javascript
- C#
- C
- C++
- Bash
- Smalltalk
- Clojure

* Als Client-Server Anwendung

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import socketserver
  import socket
  import threading

  class FizzBuzzHandler(socketserver.BaseRequestHandler):
      def handle(self):
          # received bytes from request and take the first one
          i = self.request.recv(1)[0]        
          if i % 3 == 0 and i % 5 == 0:
              answer = "fizzbuzz"
          elif i % 3 == 0:
              answer = "fizz"
          elif i % 5 == 0:
              answer = "buzz"
          else:
              answer = i

          print("[server] received:", i, "answer:", answer)

  class FizzBuzzClient:
      def __init__(self, ip, port):
          self.socket = (ip, port)

      def send(self, i):
          with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
              sock.connect(self.socket)
              print("[client] sending", i)
              sock.sendall(bytes([i]))

  def fizzbuzz_client_server():
      # Starting the server in a separate thread
      server_socket = ("127.0.0.1", 8081)
      server = socketserver.TCPServer(server_socket, FizzBuzzHandler)
      th = threading.Thread(target=server.serve_forever, daemon=True)
      th.start()

      # starting the client
      cl = FizzBuzzClient(*server_socket)
      for i in range(20):
          cl.send(i)

  fizzbuzz_client_server()

#+END_SRC

#+RESULTS[29feaa63ab858c46bf7efced5ba2825966181a8b]:
#+begin_example
[client] sending 0
[server] received: 0 answer: fizzbuzz
[client] sending 1
[server] received: 1 answer: 1
[client] sending 2
[server] received: 2 answer: 2
[client] sending 3
[server] received: 3 answer: fizz
[client] sending 4
[server] received: 4 answer: 4
[client] sending 5
[server] received: 5 answer: buzz
[client] sending 6
[server] received: 6 answer: fizz
[client] sending 7
[server] received: 7 answer: 7
[client] sending 8
[server] received: 8 answer: 8
[client] sending 9
[server] received: 9 answer: fizz
[client] sending 10
[server] received: 10 answer: buzz
[client] sending 11
[server] received: 11 answer: 11
[client] sending 12
[server] received: 12 answer: fizz
[client] sending 13
[server] received: 13 answer: 13
[client] sending 14
[server] received: 14 answer: 14
[client] sending 15
[server] received: 15 answer: fizzbuzz
[client] sending 16
[server] received: 16 answer: 16
[client] sending 17
[server] received: 17 answer: 17
[client] sending 18
[server] received: 18 answer: fizz
[client] sending 19
[server] received: 19 answer: 19
#+end_example

* Mit einer grafischen Oberfläche (GUI)

#+BEGIN_SRC python -n

import tkinter

class GUI:
    def __init__(self):
        self.i = 0

        root = tkinter.Tk()
        btn = tkinter.Button(root, text="next", command=self.button_click)
        btn.pack()
        self.ent = tkinter.Entry(root)
        self.ent.pack()
        # entering main event loop
        root.mainloop()

    def button_click(self):
        i = self.i
        # clear the entry field
        self.ent.delete(0, tkinter.END)

        if i % 3 == 0 and i % 5 == 0:
            self.ent.insert(0, "fizzbuzz")
        elif i % 3 == 0:
            self.ent.insert(0, "fizz")
        elif i % 5 == 0:
            self.ent.insert(0, "buzz")
        else:
            self.ent.insert(0, i)

        self.i += 1

def fizzbuzz_gui():
    GUI()


fizzbuzz_gui()

#+END_SRC

#+RESULTS:
: None

* Objekt-Orientiert: Klassen und Objekte verwenden

#+BEGIN_SRC python -n :results output
  class FizzBuzzerAusgabe:
      def __init__(self, n):
          self.n = n
      
      def print(self):
          i = self.n
          
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")

          
  class NumberAusgabe:
      def __init__(self, n):
          self.n = n
          
      def print(self):
          print(self.n)

          
  class FizzBuzzSpiel:
      def __init__(self, i):
          if i % 3 == 0 or i % 5 == 0:
              self.printer = FizzBuzzerAusgabe(i)
          else:
              self.printer = NumberAusgabe(i)

      def print(self):
          self.printer.print()

          
  def fizzbuzz_objektorientiert():
      for i in range(20):
          f = FizzBuzzSpiel(i)
          f.print()

  fizzbuzz_objektorientiert()
#+END_SRC

#+RESULTS:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Objekt-Orientiert mit Vererbung

#+BEGIN_SRC python -n :results output
  class FizzBuzzerAusgabe:
      def __init__(self, n):
          self.n = n
        
      def print(self):
          i = self.n
            
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")

            
  class NumberFizzBuzzerAusgabe(FizzBuzzerAusgabe):
      def __init__(self, n):
          # calling constructor of super class
          super().__init__(n)
            
      def print(self):
          if self.n % 3 == 0 or self.n % 5 == 0:
              # delegate to super class
              super().print()
          else:
              print(self.n)


  # using the classes
  for i in range(20):
      fb = NumberFizzBuzzerAusgabe(i)
      fb.print()

#+END_SRC

#+RESULTS:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Funktional mit map, reduce und lambda-Ausdrücken

#+BEGIN_SRC python -n :results output

import functools

def by(number):
    """Return a function to prove divisibility by number."""
    return (lambda i: i % number == 0)

def fizzbuzz_func(i):
    # create two functions to test for divisibility
    by5 = by(5)
    by3 = by(3)

    if by5(i) and by3(i):
        return "fizzbuzz"
    elif by3(i):
        return "fizz"
    elif by5(i):
        return "buzz"
    else:
        return i

def fizzbuzz_funktional():
    # apply fizzbuzz_func to numbers
    res = map(fizzbuzz_func, range(20))

    # reduce the result into a string
    s = functools.reduce(
        lambda acc, i: acc + str(i) + "\n", # updating function
        res, # values to be reduced
        "") # initial value

    print(s)

fizzbuzz_funktional()
#+END_SRC

#+RESULTS:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19

#+end_example

* Als Webanwendung

Bottle (https://bottlepy.org) ist ein Webframework, das leicht mit
=pip= installiert werden kann.

#+BEGIN_SRC sh :results output
pip install bottle
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): bottle in ./fizzbuzz-ve/lib/python3.5/site-packages

#+BEGIN_SRC python -n
  import bottle

  @bottle.route("/fizzbuzz/<number:int>")
  def fizzbuzz_web_route(number):    
      results = []
      for i in range(number):
          if i % 3 == 0 and i % 5 == 0:
              results.append("fizzbuzz")
          elif i % 3 == 0:
              results.append("fizz")
          elif i % 5 == 0:
              results.append("buzz")
          else:
              results.append(i)

      html = """
          <!DOCTYPE html>
          <html>
            <body>
              <h1>FizzBuzz Numbers up to {{max}}</h1>
              <table>
              % for r in results:
                <tr><td> {{r}} </td></tr>
              %end
              </table>
            </body>
          </html>
          """

      return bottle.template(html, max=number, results=results)

  def fizzbuzz_web():
      bottle.run(host="127.0.0.1", port=8081)

  fizzbuzz_web()
#+END_SRC

Nach dem Start des Webservers kann die Webseite
http://localhost:8081/fizzbuzz/20 aufgerufen werden.

* In git-repo einchecken

#+BEGIN_SRC sh -n :results output
# Ein Verzeichnis erstellen und den Quelltext kopieren
mkdir /tmp/fizzbuzz_repo
cp fizzbuzz.py /tmp/fizzbuzz_repo
cd /tmp/fizzbuzz_repo

# Repo initialisieren
git init

# Dateien für commit vormerken
git add fizzbuzz.py

# Dateien in Repo einchecken
git commit -m "commit fizzbuzz.py" fizzbuzz.py

# Logfile anschauen
git log
#+END_SRC

#+RESULTS:
: Reinitialisierte existierendes Git-Repository in /tmp/fizzbuzz_repo/.git/
: Auf Branch master
: nichts zu committen, Arbeitsverzeichnis unverändert
: commit fcc325165e397deb540afa3ad123c260d5347531
: Author: Marco Bakera <marco@bakera.de>
: Date:   Fri Apr 14 09:25:33 2017 +0200
: 
:     commit fizzbuzz.py

* Als installierbares Programm

Zunächst muss eine Datei =setup.py= angelegt werden. Sie könnte
folgenden Inhalt haben:

#+INCLUDE: "~/proj/fizzbuzz/setup.py" src python -n

Das Programm kann dann mit folgenden Befehlen installiert oder
erstellt werden:

#+BEGIN_SRC sh -n :results output
  # Release in Unterordner erstellen: 
  python setup.py sdist
#+END_SRC

#+RESULTS:
#+begin_example
running sdist
running egg_info
writing dependency_links to fizzbuzz_katas.egg-info/dependency_links.txt
writing fizzbuzz_katas.egg-info/PKG-INFO
writing top-level names to fizzbuzz_katas.egg-info/top_level.txt
reading manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
writing manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
running check
creating fizzbuzz_katas-0.1
creating fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
making hard links in fizzbuzz_katas-0.1...
hard linking setup.py -> fizzbuzz_katas-0.1
hard linking fizzbuzz_katas.egg-info/PKG-INFO -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
hard linking fizzbuzz_katas.egg-info/SOURCES.txt -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
hard linking fizzbuzz_katas.egg-info/dependency_links.txt -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
hard linking fizzbuzz_katas.egg-info/top_level.txt -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
Writing fizzbuzz_katas-0.1/setup.cfg
Creating tar archive
removing 'fizzbuzz_katas-0.1' (and everything under it)
#+end_example

Anschließend kann das Paket (lokal) installiert werden.

#+BEGIN_SRC sh -n :results output
  #  Installation:
  python setup.py install

  # Lokale Installation:
  #python setup.py install --user
#+END_SRC

#+RESULTS:
#+begin_example
running install
running bdist_egg
running egg_info
writing fizzbuzz_katas.egg-info/PKG-INFO
writing top-level names to fizzbuzz_katas.egg-info/top_level.txt
writing dependency_links to fizzbuzz_katas.egg-info/dependency_links.txt
reading manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
writing manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
creating build/bdist.linux-x86_64/egg
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/PKG-INFO -> build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/SOURCES.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/dependency_links.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/top_level.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
creating 'dist/fizzbuzz_katas-0.1-py3.5.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing fizzbuzz_katas-0.1-py3.5.egg
Removing /media/marco/2e2c3431-cdb2-4a34-bc6a-f263678c5740/home/marco/proj/fizzbuzz/fizzbuzz-ve/lib/python3.5/site-packages/fizzbuzz_katas-0.1-py3.5.egg
Copying fizzbuzz_katas-0.1-py3.5.egg to /media/marco/2e2c3431-cdb2-4a34-bc6a-f263678c5740/home/marco/proj/fizzbuzz/fizzbuzz-ve/lib/python3.5/site-packages
fizzbuzz-katas 0.1 is already the active version in easy-install.pth

Installed /media/marco/2e2c3431-cdb2-4a34-bc6a-f263678c5740/home/marco/proj/fizzbuzz/fizzbuzz-ve/lib/python3.5/site-packages/fizzbuzz_katas-0.1-py3.5.egg
Processing dependencies for fizzbuzz-katas==0.1
Finished processing dependencies for fizzbuzz-katas==0.1
#+end_example

* Als getestetes Programm (mit unittest und doctests)

#+BEGIN_SRC python -n :results output
  import unittest

  class FizzBuzz:
      def fizzbuzz(self, i):
          """Die ist ein Kommentar,der einen Test enthält. Unter Python nennt man dies
          einen doctest.

          Kommentare von Methoden lassen sich auch testen. Der folgende
          Quelltext wird hierfür ausgeführt, sobald das doctest-Modul aufgerufen
          wird:

          $ python3 -m doctest fizzbuzz.py

          Hier kommt der Test:

          >>> fbc = FizzBuzz()
          >>> fbc.fizzbuzz(3)
          'fizz'
          >>> fbc.fizzbuzz(5)
          'buzz'
          >>> fbc.fizzbuzz(10)
          'buzz'
          >>> fbc.fizzbuzz(11)
          11

          """
          if i % 3 == 0 and i % 5 == 0:
              return "fizzbuzz"
          elif i % 3 == 0:
              return "fizz"
          elif i % 5 == 0:
              return "buzz"
          else:
              return i

  class FizzBuzzTest(unittest.TestCase):
      """Diese Unit-Test-Klasse testet die Klasse FizzBuzz. 

      Hierfür testet sie mögliche Eingaben und Ausgaben."""

      def test_fizzbuzz(self):
          fb = FizzBuzz()

          self.assertEqual(fb.fizzbuzz(3), "fizz")
          self.assertEqual(fb.fizzbuzz(15), "fizzbuzz")
          self.assertEqual(fb.fizzbuzz(9), "fizz")
          self.assertEqual(fb.fizzbuzz(10), "buzz")

  def fizzbuzz_getestet():
      # Alle Tests ausführen.
      unittest.main()

  fizzbuzz_getestet()

#+END_SRC

#+RESULTS:

* Mit einem EA-Modul ansteuern

Die Bibliothek =eapi= (https://github.com/pintman/ea_rpi_modul) kann
über =pip= installiert werden.

#+BEGIN_SRC sh
pip install eapi
#+END_SRC

#+BEGIN_SRC python -n

  import eapi.hw 

  class FizzBuzzEAModul:
      def __init__(self):
          self.i = 0

          eam = eapi.hw.EAModul()
          # switching on green LED only
          eam.schalte_leds(False, False, True)
          # register for events when button0 pressed
          eam.taster_event_registrieren(0, self.taster0_gedrueckt)

          # wait for taster event
          while True:
              pass

      def taster0_gedrueckt(self, pin):
          if self.i % 3 == 0 and self.i % 5 == 0:
              print("fizzbuzz")
          elif self.i % 3 == 0:
              print("fizz")
          elif self.i % 5 == 0:
              print("buzz")
          else:
              print(self.i)

          self.i += 1

  FizzBuzzEAModul()

#+END_SRC

#+RESULTS:

Eine Hilfe zu dem Modul lässt sich über pydoc abrufen.

#+BEGIN_SRC sh :results output :exports both :cache yes
python -m pydoc eapi.hw.EAModul
#+END_SRC

#+RESULTS[071b7056b27e45c1db8d2d5613275e14cc7870ba]:
#+begin_example
Help on class EAModul in eapi.hw:

eapi.hw.EAModul = class EAModul(builtins.object)
 |  Die Klasse EAModul hilft bei der Ansteuerung eines Eingabe-Ausgabe-Moduls
 |  für den Raspberry Pi. Es besteht aus drei LED und zwei Tastern.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, pin_taster0=29, pin_taster1=31, pin_led_rot=33, pin_led_gelb=35, pin_led_gruen=37)
 |      Das Modul wird mit den gegebenen Pins konfiguriert.
 |      
 |      Pins der LEDs werden als Ausgänge und Pins der Taster als Eingänge
 |      konfiguriert. Wenn keine PINS angegeben werden, werden die PINs
 |      oberhalb des GND Pins links unten verwendet.
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      Wenn keine Werte angegeben werden, werden die Standard-Pins verwendet.
 |      
 |      >>> ea1 = EAModul()
 |      >>> ea1.cleanup()
 |      
 |      Bei einer abweichenden Verdrahtung können die Pins angegeben werden.
 |      
 |      >>> ea2 = EAModul(29, 31, 33, 35, 37)
 |      
 |      Um den Quelltext übersichtlicher zu gestalten, können die Pins
 |      direkt bezeichnet werden.
 |      
 |      >>> ea2 = EAModul(pin_taster0=29, pin_taster1=31, pin_led_rot=33,
 |      ...               pin_led_gelb=35, pin_led_gruen=37)
 |      >>> ea2.cleanup()
 |  
 |  cleanup(self)
 |      Setzt alle Pins des Pi wieder in den Ausgangszustand.
 |      
 |      >>> from eapi.hw import EAModul
 |      >>> ea = EAModul()
 |      >>> ea.cleanup()
 |  
 |  led_event_registrieren(self, led_farbe, methode)
 |      Registriert eine Methode, die ausgeführt wird, sobald die
 |      entsprechende LED ihren Wert ändert.
 |      
 |      Die Methode wird über alle Veränderungen an der LED informiert. Dazu
 |      wird die übergebene Methode aufgerufen.
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      >>> def update_rote_led(neuer_wert):
 |      ...    print("update: Status der roten LED hat sich geändert.")
 |      ...    print("Neuer Wert:", neuer_wert)
 |      
 |      >>> ea = EAModul()
 |      >>> ea.led_event_registrieren(EAModul.LED_ROT, update_rote_led)
 |      
 |      Nun wird die Update-Methode aufgerufen, sobald sich der Wert der LED
 |      ändert.
 |      
 |      >>> ea.schalte_led(EAModul.LED_ROT, 1)
 |      update: Status der roten LED hat sich geändert.
 |      Neuer Wert: 1
 |      
 |      >>> ea.schalte_led(EAModul.LED_ROT, 0)
 |      update: Status der roten LED hat sich geändert.
 |      Neuer Wert: 0
 |      
 |      >>> ea.cleanup()
 |  
 |  schalte_led(self, led_farbe, an_aus)
 |      Schalte die LED mit der gegebenen Nummer ein (1) oder aus (0).
 |      
 |      Der Wert für led_farbe ist LED_ROT, LED_GELB oder LED_GRUEN.
 |      
 |      Eine einfache Verwendung könnte wie folgt aussehen:
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      >>> ea_modul = EAModul()
 |      >>> ea_modul.schalte_led(EAModul.LED_ROT, 1)
 |      >>> ea_modul.schalte_led(EAModul.LED_GELB, 0)
 |      >>> ea_modul.schalte_led(EAModul.LED_GRUEN, 1)
 |      >>> ea_modul.cleanup()
 |  
 |  schalte_leds(self, rot_anaus, gelb_anaus, gruen_anaus)
 |      Schalte alle drei LEDs zu gleichen Zeit an oder aus.
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      >>> ea_modul = EAModul()
 |      >>> ea_modul.schalte_leds(True, False, True)
 |      >>> ea_modul.cleanup()
 |  
 |  taster_event_registrieren(self, taster_nr, methode)
 |      Registriere eine Methode, die bei Betätigung eines Tasters
 |      ausgeführt wird.
 |      
 |      Die übergebene Methode muss ein Argument haben und wird mit der
 |      Pin-Nur des Tasters aufgerufen, sobald der Taster gedrückt 
 |      wird. Eine einfache Verwendung könnte wie folgt aussehen:
 |      
 |      >>> def taster0_gedrueckt(pin):
 |      ...  print("Taster 0 wurde gedrückt.")
 |      
 |      >>> ea_modul = EAModul()
 |      >>> ea_modul.taster_event_registrieren(0, taster0_gedrueckt)
 |      >>> ea_modul.cleanup()
 |  
 |  taster_gedrueckt(self, num=0)
 |      Liest den Wert des Tasters mit der gegebenen Nummer aus und gibt den
 |      Wert zurück. Eine einfache Verwendung könnte wie folgt aussehen:
 |      
 |      >>> from eapi.hw import EAModul
 |      >>> import time
 |      
 |      >>> ea_modul = EAModul()
 |      >>> while not ea_modul.taster_gedrueckt(1):
 |      ...   ea_modul.schalte_led(EAModul.LED_ROT, 1)
 |      ...   time.sleep(0.2)
 |      ...   ea_modul.schalte_led(EAModul.LED_ROT, 0)
 |      >>> ea_modul.cleanup()
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  LED_GELB = 1
 |  
 |  LED_GRUEN = 2
 |  
 |  LED_ROT = 0

#+end_example

* Mit Anbindung an eine Datenbank

#+BEGIN_SRC python -n :results output

import sqlite3

def fizzbuzz_insert_into_db():
    conn = sqlite3.connect("fizzbuzz.db")
    c = conn.cursor()
    c.execute("CREATE TABLE IF NOT EXISTS fizzbuzz(nr int, ergebnis text)")

    for i in range(20):
        erg = ""
        if i % 3 == 0 and i % 5 == 0:
            erg = "fizzbuzz"
        elif i % 3 == 0:
            erg = "fizz"
        elif i % 5 == 0:
            erg = "buzz"
        else:
            erg = i

        c.execute("INSERT INTO fizzbuzz VALUES(?,?)", (i,erg))

    conn.commit()
    conn.close()

def fizzbuzz_select_from_db():
    conn = sqlite3.connect("fizzbuzz.db")
    c = conn.cursor()
    rows = c.execute("SELECT nr, ergebnis FROM fizzbuzz")

    print("Nr.\tErgebnis")
    for i,erg in rows:
        print(i, "    ", erg)

    conn.close()

fizzbuzz_insert_into_db()
fizzbuzz_select_from_db()
#+END_SRC

#+RESULTS:
#+begin_example
Nr.	Ergebnis
0      fizzbuzz
1      1
2      2
3      fizz
4      4
5      buzz
6      fizz
7      7
8      8
9      fizz
10      buzz
11      11
12      fizz
13      13
14      14
15      fizzbuzz
16      16
17      17
18      fizz
19      19
#+end_example

Nach dem Versuch entsteht eine Datei =fizzbuzz.db=, die man mit
=sqlite= befragen oder auch einfach kopieren und löschen kann.

#+BEGIN_SRC sh
rm fizzbuzz.db
#+END_SRC

#+RESULTS:

* Mit docstring Dokumentation
#+BEGIN_SRC python -n :results output :exports both :cache yes

def fizzbuzz_dokumentiert(n):
    """Diese Methode durchläuft die Zahlen 1 bis n. Sie gibt 'fizz' aus,
    wenn die Zahl durch 3 ist, 'buzz', wenn sie durch 5 teilbar ist
    und 'fizzbuzz', wenn sie durch 3 und 5 teilbar ist."""

    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            print("fizzbuzz")
        elif i % 3 == 0:
            print("fizz")
        elif i % 5 == 0:
            print("buzz")
        else:
            print(i)

help(fizzbuzz_dokumentiert)
#+END_SRC

#+RESULTS[b361da44808c18519ce7d67d0a7578413e59b8e9]:
: Help on function fizzbuzz_dokumentiert in module __main__:
: 
: fizzbuzz_dokumentiert(n)
:     Diese Methode durchläuft die Zahlen 1 bis n. Sie gibt 'fizz' aus,
:     wenn die Zahl durch 3 ist, 'buzz', wenn sie durch 5 teilbar ist
:     und 'fizzbuzz', wenn sie durch 3 und 5 teilbar ist.
: 

Der Kommentar einer Methode oder Klasse steht immer als erster
String in der Deklaration.

Er kann im Python-Interpreter mit =help()= abgerufen werden:

Außerdem gibt es das Modul =pydoc=, mit dem eine Dokumentation auf der
Kommandozeile oder über einen Webserver zur Verfügung steht.

#+BEGIN_SRC sh
pydoc3 fizzbuzz.fizzbuzz_dokumentiert
python -m pydoc fizzbuzz.fizzbuzz_dokumentiert
#+END_SRC

#+RESULTS:
: problem in fizzbuzz - ImportError: No module named 'sopel'

Webserver starten auf Port 8080 mit Dokumentation unter
http://localhost:8080

#+BEGIN_SRC sh
pydoc -p 8080

# alternativ:
python -m pydoc -p 8080
#+END_SRC

* Als Chatbot 

Wir verwenden hier sopel als Web-Framework (https://sopel.chat/ und
https://github.com/sopel-irc/sopel/wiki).

Installation
#+BEGIN_SRC sh :results output
pip install sopel
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): sopel in ./fizzbuzz-ve/lib/python3.5/site-packages
: Requirement already satisfied (use --upgrade to upgrade): xmltodict in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): pytz in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): praw in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): pyenchant in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): pygeoip in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): requests<2.11.0,>=2.0.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): update-checker>=0.16 in ./fizzbuzz-ve/lib/python3.5/site-packages (from praw->sopel)
: Requirement already satisfied (use --upgrade to upgrade): prawcore<0.9,>=0.8.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from praw->sopel)


Konfiguration (in =~/.sopel=) erstellen: 
#+BEGIN_SRC sh
sopel
#+END_SRC

Nach ein paar Fragen könnte die Konfiguration wie folgt aussehen.

#+INCLUDE: "~/.sopel/fizzbuzz.cfg" src sh -n

Eigenen Bot in =~/.sopel/modules/fizzbuzz.py= erstellen

#+BEGIN_SRC python -n
from sopel import module

@module.commands('fizzbuzz')
def echo(bot, trigger):
    # to everybody:   bot.say("...")
    # to querstioner: bot.reply("...")

    # take and convert argument
    i = int(trigger.group(2))

    if i % 3 == 0 and i % 5 == 0:
        bot.reply("fizzbuzz")
    elif i % 3 == 0:
        bot.reply("fizz")
    elif i % 5 == 0:
        bot.reply("buzz")
    else:
        bot.reply(i)
#+END_SRC

Sopel starten
#+BEGIN_SRC sh
sopel
#+END_SRC
           
Eine mögliche Chat-Konversation (Sopel-Befehle beginnen mit einem
Punkt):

#+BEGIN_EXAMPLE
= FizzBuzzBot has joined
<fizzbuzz_owner> .fizzbuzz 1
<FizzBuzzBot>    fizzbuzz_owner: 1
<fizzbuzz_owner> .fizzbuzz 2
<FizzBuzzBot>    fizzbuzz_owner: 2
<fizzbuzz_owner> .fizzbuzz 3
<FizzBuzzBot>    fizzbuzz_owner: fizz
<fizzbuzz_owner> .fizzbuzz 5
<FizzBuzzBot>    fizzbuzz_owner: buzz
<fizzbuzz_owner> .fizzbuzz 14
<FizzBuzzBot>    fizzbuzz_owner: 14
<fizzbuzz_owner> .fizzbuzz 15
<FizzBuzzBot>    fizzbuzz_owner: fizzbuzz
#+END_EXAMPLE

* Auf einem Cluster (mit GNU parallel)

Hierfür bedienen wir uns des Programmes GNU parallel. Es muss auf dem
Rechner installiert sein oder lässt sich unter Ubuntu leicht nachinstallieren.

#+BEGIN_SRC 
sudo apt-get install parallel
#+END_SRC

Wir nutzen die folgende Datei =fizzbuzz.py=.

#+BEGIN_SRC python -n
  import sys

  def fizzbuzz_cluster():
      i = int (sys.argv[1])

      if i % 3 == 0 and i % 5 == 0:
          print(i, "fizzbuzz")
      elif i % 3 == 0:
          print(i, "fizz")
      elif i % 5 == 0:
          print(i, "buzz")
      else:
          print(i, i)

  fizzbuzz_cluster()
#+END_SRC

Zuerst muss die Datei =fizzbuzz.py= auf jeden Rechner im Cluster
übertragen werden und der ssh-login gemäß der Beschreibung in =man
parallel= eingerichtet worden sein. Dies wird im Abschnitt "EXAMPLE:
Using remote computers" der man-page beschrieben.

Nun folgt der Aufruf:

#+BEGIN_SRC sh
seq 20 | parallel --sshlogin server1,server2,server3 python3 fizzbuzz.py
#+END_SRC

=seq 20= generiert die Zahlen 1 bis 20 und sendet sie über eine Pipe (=|=)
an den Befehl =parallel=. Dieser verteilt die Aufrufe

- =python3 fizzbuzz.py 1=,
- =python3 fizzbuzz.py 2=,
- =python3 fizzbuzz.py 3=,
- =python3 fizzbuzz.py 4=',

auf die Server server1, server2 und server3.

* In einem UML-Aktivitätsdiagramm

#+BEGIN_SRC plantuml :file doc/fizzbuzz-aktdiag.png :cache yes
@startuml
start
:zahl = 1;
while (zahl <= 20) is (ja)

if (zahl mod 3 == 0 und zahl mod 5 == 0) then (ja)
    :Ausgabe "fizzbuzz";
else (nein)
    if (zahl mod 3 == 0) then (ja)
        :Ausgabe "fizz";
    else (nein)
    	if (zahl mod 5 == 0) then (ja)
      	    :Ausgabe "buzz";
        else (nein)
	    :Ausgabe zahl;
	endif
    endif
endif
  
:zahl = zahl +1;
  
endwhile  (nein)

stop

@enduml
#+END_SRC

#+RESULTS[7bf18c2091416d56db25e7fd95f57a3963107119]:
[[file:doc/fizzbuzz-aktdiag.png]]

* In einem UML-Sequenzdiagramm

Der FizzbuzzServer hat eine Methode =fizzbuzz(zahl: int): answer=, die
von einem Client mit einer Zahl aufgerufen werden kann. Die Antwort
ist eine Zahl oder ein String.

#+BEGIN_SRC plantuml :file doc/fizzbuzz-seqdiag.png :cache yes
@startuml
Client -> FizzbuzzServer: fizzbuzz(2)
FizzbuzzServer --> Client: 2
Client -> Client: Ausgabe 2

Client -> FizzbuzzServer: fizzbuzz(3)
FizzbuzzServer --> Client: "fizz"
Client -> Client: Ausgabe "fizz"

Client -> FizzbuzzServer: fizzbuzz(5)
FizzbuzzServer --> Client: "buzz"
Client -> Client: Ausgabe "buzz"

Client -> FizzbuzzServer: fizzbuzz(zahl)

alt zahl % 3 == 0 and zahl % 5 == 0
    FizzbuzzServer --> Client: "fizzbuzz"
    Client -> Client: Ausgabe "fizzbuzz"
else zahl % 3 == 0
    FizzbuzzServer --> Client: "fizz"
    Client -> Client: Ausgabe "fizz"
else zahl % 5 == 0
    FizzbuzzServer --> Client: "buzz"
    Client -> Client: Ausgabe "buzz"
else sonst
    FizzbuzzServer --> Client: zahl
    Client -> Client: Ausgabe zahl

end
@enduml
#+END_SRC

#+RESULTS[ce4baf64489ce021c830488dd8ed7060e96fc4c7]:
[[file:doc/fizzbuzz-seqdiag.png]]

* In einem UML-Klassendiagramm

file:doc/fizzbuzz-klassendiagramm.png

Dies Klasse könnte wie folgt verwendet werden.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  class FizzBuzz:
      def __init__(self, n):
          self.num = n

      def fizzbuzz(self):
          if self.num % 3 == 0 and self.num % 5 == 0:
              return "fizzbuzz"
          elif self.num % 3 == 0:
              return "fizz"
          elif self.num % 5 == 0:
              return "buzz"
          else:
              return self.num

  fb = FizzBuzz(2)
  print("Eingabe:", 2, "Ausgabe:", fb.fizzbuzz())
  fb = FizzBuzz(15)
  print("Eingabe:", 15, "Ausgabe:", fb.fizzbuzz())
#+END_SRC

#+RESULTS[72e8deaa5f8f1d0abf0348e137bceb645c4b2cfd]:
: Eingabe: 2 Ausgabe: 2
: Eingabe: 15 Ausgabe: fizzbuzz

* Als IOT-Anwendung mit einem Message-Broker (MQTT)

Als Client-Bibliothek wird =paho-mqtt=
(https://pypi.python.org/pypi/paho-mqtt/) verwendet. Diese lässt
sich einfach installieren.

#+BEGIN_SRC sh
pip install paho-mqtt
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): paho-mqtt in ./fizzbuzz-ve/lib/python3.5/site-packages

Eine mögliche Kommunikation zwischen zwei Clients und dem Broker.

#+BEGIN_SRC plantuml :file doc/fizzbuzz-mqtt.png :cache yes
@startuml
subscriber -> Broker: connect()
publisher -> Broker: connect()

subscriber -> Broker: subscribe("fizzbuzz/")
publisher -> Broker: publish("fizzbuzz/", "2")
Broker -> subscriber: on_message(2)
subscriber -> subscriber: print(2)

publisher -> Broker: publish("fizzbuzz/", "3")
Broker -> subscriber: on_message(3)
subscriber -> subscriber: print("fizz")

publisher -> Broker: publish("falscher_kanal/", "2")

@enduml
#+END_SRC

#+RESULTS[727e051b35e673ad3e2a799f958d9f0cc7da8039]:
[[file:doc/fizzbuzz-mqtt.png]]


#+BEGIN_SRC python -n :results output :exports both :cache yes
  import paho.mqtt.client as mqtt
  import threading
  import time

  class FizzbuzzPublisher:
      def __init__(self, server="iot.eclipse.org", port=1883):
          self.client = mqtt.Client()
          self.client.connect(server, port, keepalive=60)
      
      def publish(self, payload):
          print("[publish]", payload)
          self.client.publish("fizzbuzz/", payload)

          
  class FizzbuzzSubscriber:
      def __init__(self, server="iot.eclipse.org", port=1883):
          self.client = mqtt.Client()
          self.client.on_connect = self.on_connect
          self.client.on_message = self.on_message
          self.client.connect(server, port, keepalive=60)

      def start(self):
          self.client.loop_forever()

      def on_connect(self, client, userdata, flags, rc):
          print("[connected]")
          self.client.subscribe("fizzbuzz/")
      
      def on_message(self, client, userdata, msg):
          i = int(msg.payload)
          
          if i % 3 == 0 and i % 5 == 0:
              answer = "fizzbuzz"
          elif i % 3 == 0:
              answer = "fizz"
          elif i % 5 == 0:
              answer = "buzz"
          else:
              answer = i

          print("[msg reveived] topic:", msg.topic, "payload:", i, "answer:", answer)


  #### Subscriber ####
          
  # Start thread in background that responds to messages
  print("[subscribing]")
  sub = FizzbuzzSubscriber()
  th1 = threading.Thread(target=sub.start, daemon=True)
  th1.start()

  #### Publisher ####

  print("[start publishing]")
  pub = FizzbuzzPublisher()
  for i in range(1,21):
      pub.publish(i)
      # waiting some time and give the subscribed client time to do the job.
      time.sleep(0.1)

  time.sleep(1)

#+END_SRC

#+RESULTS[74b3dfeeb0156d002cf9f2721a9733b0c8d945f2]:
#+begin_example
[subscribing]
[start publishing]
[publish] 1
[connected]
[publish] 2
[publish] 3
[publish] 4
[msg reveived] topic: fizzbuzz/ payload: 1 answer: 1
[msg reveived] topic: fizzbuzz/ payload: 2 answer: 2
[publish] 5
[publish] 6
[publish] 7
[publish] 8
[publish] 9
[publish] 10
[msg reveived] topic: fizzbuzz/ payload: 3 answer: fizz
[publish] 11
[msg reveived] topic: fizzbuzz/ payload: 4 answer: 4
[msg reveived] topic: fizzbuzz/ payload: 5 answer: buzz
[msg reveived] topic: fizzbuzz/ payload: 6 answer: fizz
[msg reveived] topic: fizzbuzz/ payload: 7 answer: 7
[msg reveived] topic: fizzbuzz/ payload: 8 answer: 8
[msg reveived] topic: fizzbuzz/ payload: 9 answer: fizz
[publish] 12
[msg reveived] topic: fizzbuzz/ payload: 10 answer: buzz
[publish] 13
[publish] 14
[msg reveived] topic: fizzbuzz/ payload: 11 answer: 11
[msg reveived] topic: fizzbuzz/ payload: 12 answer: fizz
[publish] 15
[msg reveived] topic: fizzbuzz/ payload: 13 answer: 13
[publish] 16
[msg reveived] topic: fizzbuzz/ payload: 14 answer: 14
[publish] 17
[publish] 18
[msg reveived] topic: fizzbuzz/ payload: 15 answer: fizzbuzz
[msg reveived] topic: fizzbuzz/ payload: 16 answer: 16
[publish] 19
[msg reveived] topic: fizzbuzz/ payload: 17 answer: 17
[publish] 20
[msg reveived] topic: fizzbuzz/ payload: 18 answer: fizz
[msg reveived] topic: fizzbuzz/ payload: 19 answer: 19
[msg reveived] topic: fizzbuzz/ payload: 20 answer: buzz
#+end_example

* Mit Kommandozeilenparametern

#+INCLUDE: "fizzbuzz-cli.py" src python -n

Aufruf mit einem Parameter:

#+BEGIN_SRC sh :results output :exports both :cache yes
python fizzbuzz-cli.py 20
#+END_SRC

#+RESULTS[b5b05a43541d82fb48b9e5d7821951fe87ebb0a5]:
#+begin_example
Evaluating command line: ['fizzbuzz-cli.py', '20']
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

Mit dem Paket =argparse=
(https://docs.python.org/3/library/argparse.html) wird die Auswertung
von Kommandozeilenparametern manchmal vereinfacht.

#+INCLUDE: "fizzbuzz-argparse.py" src python -n

Nun steht eine Hilfe zur Verfügung:

#+BEGIN_SRC sh :results output :exports both :cache yes
python fizzbuzz-argparse.py --help
#+END_SRC

#+RESULTS[b2b9fcc4d34f2f2f088b9e97049f5f10337af69a]:
: usage: fizzbuzz-argparse.py [-h] [--max_wert MAX_WERT]
: 
: FizzBuzz Spiel
: 
: optional arguments:
:   -h, --help           show this help message and exit
:   --max_wert MAX_WERT  Bis zu diesem Wert wird gezählt

Aufruf mit einem Parameter.

#+BEGIN_SRC sh :results output
python fizzbuzz-argparse.py --max_wert 20
#+END_SRC

#+RESULTS:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Mit einer Konfigurationsdatei

Mit dem Paket =configparser=
(https://docs.python.org/3/library/configparser.html) kann eine
Konfigurationsdatei ausgewertet werden.

Die Datei =fizzbuzz.ini=:

#+INCLUDE: "fizzbuzz.ini" src python -n

Auswerten der Datei:

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import configparser

  def fizzbuzz(n):
      for i in range(n):
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)

  config = configparser.ConfigParser()
  config.read("fizzbuzz.ini")

  beschreibung = config["informationen"]["beschreibung"]
  print("Beschreibung:", beschreibung)

  conf_num = config["default"]["max_wert"]
  num = int(conf_num)
  fizzbuzz(num)


#+END_SRC

#+RESULTS[87f9b7644932e5f4182f2d64b3a916f6f5cf2e4b]:
#+begin_example
Beschreibung: Ein Zählspiel
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Als Web-Service mit REST-API

=hug= (http://www.hug.rest/) stellt eine einfache Schnittstelle für
REST-Web-Services bereit.

#+BEGIN_SRC sh :results output
pip install hug
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): hug in ./fizzbuzz-ve/lib/python3.5/site-packages
: Requirement already satisfied (use --upgrade to upgrade): falcon==1.0.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from hug)
: Requirement already satisfied (use --upgrade to upgrade): requests in ./fizzbuzz-ve/lib/python3.5/site-packages (from hug)
: Requirement already satisfied (use --upgrade to upgrade): python-mimeparse in ./fizzbuzz-ve/lib/python3.5/site-packages (from falcon==1.0.0->hug)
: Requirement already satisfied (use --upgrade to upgrade): six>=1.4.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from falcon==1.0.0->hug)

Ein einfacher Service wird mit der Annotation =@hug.get()=
ausgestattet.

#+INCLUDE: "~/proj/fizzbuzz/fizzbuzz_hug.py" src python -n

Server auf Port 8081 starten:

#+BEGIN_SRC sh 
hug -p 8081 -f fizzbuzz_hug.py
#+END_SRC

#+RESULTS:

Nun kann der Web-Service abgerufen werden (für Tests z.B. mit
curl). Wenn keine korrekte URL angegeben wird, liefert hug eine Hilfe.

#+BEGIN_SRC sh :results output :exports both :cache yes
curl localhost:8081
#+END_SRC

#+RESULTS[af04781cfa76759215e0224901cfc913d06f1a36]:
#+begin_example
{
    "404": "The API call you tried to make was not defined. Here's a definition of the API to help you get going :)",
    "documentation": {
        "handlers": {
            "/fizzbuzz": {
                "GET": {
                    "usage": "Return fizzbuzz up to the given number.",
                    "outputs": {
                        "format": "JSON (Javascript Serialized Object Notation)",
                        "content_type": "application/json"
                    },
                    "inputs": {
                        "max_number": {
                            "type": "Basic text / string value"
                        }
                    }
                }
            }
        }
    }
}
#+end_example

Nun mit einer bekannten URL.

#+BEGIN_SRC sh :results output :exports both :cache yes
curl localhost:8081/fizzbuzz?max_number=10
#+END_SRC

#+RESULTS[817e61e632bf3667e616f7d831d512036707b26b]:
: {"0": "fizzbuzz", "1": 1, "2": 2, "3": "fizz", "4": 4, "5": "buzz", "6": "fizz", "7": 7, "8": 8, "9": "fizz"}

Alternative mit Parameter im Request:

#+BEGIN_SRC sh :results output
curl localhost:8081/fizzbuzz --data max_number=10 --request GET
#+END_SRC

#+RESULTS[8747c8df176c2a6ab70e55e09412c44a2e9a4059]:
: {"0": "fizzbuzz", "1": 1, "2": 2, "3": "fizz", "4": 4, "5": "buzz", "6": "fizz", "7": 7, "8": 8, "9": "fizz"}

