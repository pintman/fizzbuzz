#+TITLE: FizzBuzz Katas
#+LANGUAGE: de
#+HTML_HEAD: <link rel="stylesheet" href="styles/org.css" type="text/css" />

FizzBuzz ist ein Zählspiel, bei dem die Zahlen bis 100 aufgezählt
werden. Ist die Zahl durch 3 teilbar, wird "fizz" gesagt. Ist sie
durch 5 teilbar, wird "buzz" gesagt. Ist sie durch 3 und 5 teilbar,
wird "fizzbuzz" gesagt. Ansonsten wird die Zahl selbst gesagt.

Wir versuchen uns auf dem Blatt mit einer Aufwärmübung (Kata). Die
anschließenden Übungen lösen alle dasselbe fizzbuzz-Problem, nutzen
jedoch ganz unterschiedliche Herangehensweisen oder Technologien.

* Auf Papier

#+BEGIN_EXAMPLE
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+END_EXAMPLE

* Mit einer Methode
Hier ist eine erste einfache Variante.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  def fizzbuzz_method(n):
      for i in range(n):
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)

  fizzbuzz_method(20)
#+END_SRC

#+RESULTS[bd9026c891e7587925901e332d160d6dc41c6e44]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

Das nächste Beispiel wandelt die obige Variante ab, erzeugt aber
dieselbe Ausgabe.

#+BEGIN_SRC python -n :results output :cache yes
  def fizzbuzz_method(n):
      for i in range(n):
          s = ""

          if i % 3 == 0:
              s = "fizz"
          if i % 5 == 0:
              s += "buzz"
          if len(s) == 0:
              s = i

          print(s)

  fizzbuzz_method(20)

#+END_SRC

#+RESULTS[60e4ba3bc73e7c7497bff8c7d82470fa38697060]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Ohne Verwendung einer Schleife (rekursiv)

#+BEGIN_SRC python -n :results output :cache yes

  def fizzbuzz_recursive(i):
      if i == 0:
          return
      else:
          fizzbuzz_recursive(i-1)

          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)


  fizzbuzz_recursive(20)
#+END_SRC

#+RESULTS[4e74b55d5e3fa6c36faea833b7bcbeb649389a84]:
#+begin_example
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
buzz
#+end_example

* Mit Hilfe von nebenläufigen Threads und Prozessen

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import threading
  import time

  def fizzbuzz_thread(i):    
      time.sleep(1)
      if i % 3 == 0 and i % 5 == 0:
          print(i, "fizzbuzz")
      elif i % 3 == 0:
          print(i, "fizz")
      elif i % 5 == 0:
          print(i, "buzz")
      else:
          print(i)

  def fizzbuzz_start_threads():
      for i in range(20):
          # Creating a thread object that will execute the method above
          # with the given argument i.
          th = threading.Thread(target=fizzbuzz_thread, args=(i,))
          th.start()

  fizzbuzz_start_threads()
#+END_SRC

#+RESULTS[86f7fd2964c87c11c0d562188945a6f028ce3f63]:
#+begin_example
3 fizz
4
2
1
0 fizzbuzz
5 buzz
7
6 fizz
10 buzz
8
11
9 fizz
14
15 fizzbuzz
16
17
13
18 fizz
12 fizz
19
#+end_example

Die Ausgabe kann bei jedem Start in einer anderen Reihenfolge
erfolgen, da die Methodenaufrufe fast gleichzeitig erfolgen. Obwohl
die Methode =fizzbuzz_thread()= zu Beginn wartet, ist das Programm
schnell beendet, da die Threads nicht sequentiell ablaufen, sondern
gleichzeitig.

In einer zweiten Variante verwenden wir echte Prozesse des
Betriebssystems, die auch auf verschiedene Kerne oder Prozessoren
aufgeteilt werden können. Hierfür gibt es das Paket [[https://docs.python.org/3/library/multiprocessing.html][multiprocessing]].

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import time
  import multiprocessing
      
  def fizzbuzz_process(i):
      time.sleep(1)
      if i % 3 == 0 and i % 5 == 0:
          print(i, "fizzbuzz")
      elif i % 3 == 0:
          print(i, "fizz")
      elif i % 5 == 0:
          print(i, "buzz")
      else:
          print(i)

  def fizzbuzz_start_processes():
      for i in range(20):
          # Creating a process that will execute the method above
          # with the given argument i.
          pr = multiprocessing.Process(target=fizzbuzz_process, args=(i,))
          pr.start()

  fizzbuzz_start_processes()

#+END_SRC

#+RESULTS[fa3c2851ff9b25d55546cd50bfe57d56996b790d]:
#+begin_example
0 fizzbuzz
1
2
3 fizz
4
5 buzz
6 fizz
7
9 fizz
8
10 buzz
11
12 fizz
13
15 fizzbuzz
14
16
17
18 fizz
19
#+end_example

Auch hier ist die Ausgabereihenfolge nicht-deterministisch. Zudem
sieht man nun in einem Task-Manager, dass viele verschiedene Prozesse
kurz gestartet werden.

* Mit einer anderen IDE

Mögliche Kandidaten wären:

- IDLE
- PyCharm
- Emacs
- vim
- Atom

* In einer anderen Programmiersprache

Mögliche Sprachen wären:

- Java
- Javascript
- C#
- C
- C++
- Bash
- Smalltalk
- Clojure
- eine Esoterische Programmiersprache (der Vortrag [[https://media.ccc.de/v/gpn17-8545-esoterische_programmiersprachen][Esoterische
  Programmiersprachen]] stellt ein paar Vertreter vor)

* Als Client-Server Anwendung

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import socketserver
  import socket
  import threading

  class FizzBuzzHandler(socketserver.BaseRequestHandler):
      def handle(self):
          # received bytes from request and take the first one
          i = self.request.recv(1)[0]        
          if i % 3 == 0 and i % 5 == 0:
              answer = "fizzbuzz"
          elif i % 3 == 0:
              answer = "fizz"
          elif i % 5 == 0:
              answer = "buzz"
          else:
              answer = i

          print("[server] received:", i, "answer:", answer)

  class FizzBuzzClient:
      def __init__(self, ip, port):
          self.socket = (ip, port)

      def send(self, i):
          with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
              sock.connect(self.socket)
              print("[client] sending", i)
              sock.sendall(bytes([i]))

  def fizzbuzz_client_server():
      # Starting the server in a separate thread
      server_socket = ("127.0.0.1", 8081)
      server = socketserver.TCPServer(server_socket, FizzBuzzHandler)
      th = threading.Thread(target=server.serve_forever, daemon=True)
      th.start()

      # starting the client
      cl = FizzBuzzClient(*server_socket)
      for i in range(20):
          cl.send(i)

  fizzbuzz_client_server()

#+END_SRC

#+RESULTS[29feaa63ab858c46bf7efced5ba2825966181a8b]:
#+begin_example
[client] sending 0
[server] received: 0 answer: fizzbuzz
[client] sending 1
[server] received: 1 answer: 1
[client] sending 2
[server] received: 2 answer: 2
[client] sending 3
[server] received: 3 answer: fizz
[client] sending 4
[server] received: 4 answer: 4
[client] sending 5
[server] received: 5 answer: buzz
[client] sending 6
[server] received: 6 answer: fizz
[client] sending 7
[server] received: 7 answer: 7
[client] sending 8
[server] received: 8 answer: 8
[client] sending 9
[server] received: 9 answer: fizz
[client] sending 10
[server] received: 10 answer: buzz
[client] sending 11
[server] received: 11 answer: 11
[client] sending 12
[server] received: 12 answer: fizz
[client] sending 13
[server] received: 13 answer: 13
[client] sending 14
[server] received: 14 answer: 14
[client] sending 15
[server] received: 15 answer: fizzbuzz
[client] sending 16
[server] received: 16 answer: 16
[client] sending 17
[server] received: 17 answer: 17
[client] sending 18
[server] received: 18 answer: fizz
[client] sending 19
[server] received: 19 answer: 19
#+end_example

* Mit einer grafischen Oberfläche (GUI)

Mit Python wird das einfache Paket =tkinter= für die Gestaltung von
GUIs mitgeliefert. Eine ausführliche Dokumentation ist unter
http://effbot.org/tkinterbook/ zu finden.

file:doc/fizzbuzz_gui.png

#+BEGIN_SRC python -n
  import tkinter

  class GUI:
      def __init__(self):
          self.i = 0

          root = tkinter.Tk()
          root.title("FizzBuzz")

          # add menu
          menubar = tkinter.Menu(root)
          root.config(menu=menubar)
          # adding Tools-menu to menubar
          tools_menu = tkinter.Menu(menubar)
          menubar.add_cascade(label="Tools", menu=tools_menu)
          tools_menu.add_command(label="Next", command=self.click)

          # add button
          btn = tkinter.Button(root, text="next", command=self.click)
          btn.pack()

          self.lbl = tkinter.Label(root, text="fizzbuzz GUI")
          self.lbl.pack()
          self.ent = tkinter.Entry(root)
          self.ent.pack()
          # entering main event loop
          root.mainloop()

      def click(self):
          i = self.i

          # update label
          self.lbl.configure(text="fizzbuzz von " + str(i))
          
          # clear the entry field
          self.ent.delete(0, tkinter.END)

          if i % 3 == 0 and i % 5 == 0:
              self.ent.insert(0, "fizzbuzz")
          elif i % 3 == 0:
              self.ent.insert(0, "fizz")
          elif i % 5 == 0:
              self.ent.insert(0, "buzz")
          else:
              self.ent.insert(0, i)

          self.i += 1

  GUI()
#+END_SRC

#+RESULTS:
: None

* Objekt-Orientiert: Klassen und Objekte verwenden

#+BEGIN_SRC python -n :results output :cache yes
  class FizzBuzzerOutput:
      def __init__(self, n):
          self.n = n
      
      def print(self):
          i = self.n
          
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")

          
  class NumberOutput:
      def __init__(self, n):
          self.n = n
          
      def print(self):
          print(self.n)

          
  class FizzBuzzGame:
      def __init__(self, i):
          if i % 3 == 0 or i % 5 == 0:
              self.printer = FizzBuzzerOutput(i)
          else:
              self.printer = NumberOutput(i)

      def print(self):
          self.printer.print()

          
  for i in range(20):
      f = FizzBuzzGame(i)
      f.print()

#+END_SRC

#+RESULTS[49c326f6182319119be1400b452d68c26a4fa4f9]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Objekt-Orientiert mit Vererbung

Wir verwenden zwei Klassen =Game= und =FizzBuzzGame=, wobei letztere
die erstere erweitert und damit alle Attribute und Methoden von dieser
übernimmt und ggf. um weitere ergänzt. Man kann sagen =FizzbuzzGame=
ist ein =Game=. Durch die Vererbung muss nicht jedes neue Spiel die
Gameloop erneut programmieren, sondern kann diese generische
Funktionalität übernehmen.

#+INCLUDE: "fizzbuzz_vererbung.py" src python -n

Wir simulieren ein Spiel, indem wir testweise die Eingaben 1, 2 und
"fizz" an das Spiel senden (Spielereingaben tauchen daher nicht in der
Ausgabe auf).

#+BEGIN_SRC sh :results output :exports both :cache yes
/bin/echo -e "1\n2\nfizz\n4\nbuzz\n" | python3 fizzbuzz_vererbung.py
#+END_SRC

#+RESULTS[221c1b86c7bd0b8b478827f2944dbc5293eabaad]:
: Spiel gestartet
: 1 ? Richtig :)
: 2 ? Richtig :)
: 3 ? Richtig :)
: 4 ? Richtig :)
: 5 ? Gewonnen!

* Funktional mit map, reduce und lambda-Ausdrücken

#+BEGIN_SRC python -n :results output :cache yes

import functools

def by(number):
    """Return a function to prove divisibility by number."""
    return (lambda i: i % number == 0)

def fizzbuzz_func(i):
    # create two functions to test for divisibility
    by5 = by(5)
    by3 = by(3)

    if by5(i) and by3(i):
        return "fizzbuzz"
    elif by3(i):
        return "fizz"
    elif by5(i):
        return "buzz"
    else:
        return i

def fizzbuzz_functional():
    # apply fizzbuzz_func to numbers
    res = map(fizzbuzz_func, range(20))

    # reduce the result into a string
    s = functools.reduce(
        lambda acc, i: acc + str(i) + "\n", # updating function
        res, # values to be reduced
        "") # initial value

    print(s)

fizzbuzz_functional()
#+END_SRC

#+RESULTS[2f953abf5889cd92a67b6daec94983a487e3fa37]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19

#+end_example

* Als Webanwendung

Bottle (https://bottlepy.org) ist ein Webframework, das leicht mit
=pip= installiert werden kann.

#+BEGIN_SRC sh :results output
pip install bottle
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): bottle in ./fizzbuzz-ve/lib/python3.5/site-packages

#+BEGIN_SRC python -n
  import bottle

  @bottle.route("/fizzbuzz/<number:int>")
  def fizzbuzz_web_route(number):    
      results = []
      for i in range(number):
          if i % 3 == 0 and i % 5 == 0:
              results.append("fizzbuzz")
          elif i % 3 == 0:
              results.append("fizz")
          elif i % 5 == 0:
              results.append("buzz")
          else:
              results.append(i)

      html = """
          <!DOCTYPE html>
          <html>
            <body>
              <h1>FizzBuzz Numbers up to {{max}}</h1>
              <table>
              % for r in results:
                <tr><td> {{r}} </td></tr>
              %end
              </table>
            </body>
          </html>
          """

      return bottle.template(html, max=number, results=results)

  def fizzbuzz_web():
      bottle.run(host="127.0.0.1", port=8081)

  fizzbuzz_web()
#+END_SRC

Nach dem Start des Webservers kann die Webseite
http://localhost:8081/fizzbuzz/20 aufgerufen werden.

Die Webanwendung kann in einen bestehenden Webserver, wie z.B. apache
mit Hilfe des Moduls [[http://www.modwsgi.org][mod wsgi]] integriert werden. Die Integration wird
z.B. in der [[http://bottlepy.org/docs/dev/deployment.html][Dokumentation von bottlepy]] beschrieben.

Zunächst wird das apache2-Modul installiert. Eine Dokumentation
befindet sich danach unter =/usr/share/doc/libapache2-mod-py3=.

#+BEGIN_SRC sh
sudo apt install libapache2-mod-py3
#+END_SRC

Die folgende Datei wird als Einstiegspunkt im Webroot abgelegt -
z.B. in =/var/www/fizzbuzz/index.wsgi=.

#+INCLUDE: "fizzbuzz_index.wsgi" src python -n

Anschließend wird die Webserverkonfiguration so angepasst, dass sie
den neuen Einstiegspunkt verwendet:

#+BEGIN_SRC html
  <VirtualHost *>
      ServerName www.example.com

      WSGIDaemonProcess fizzbuzz user=www-data group=www-data processes=1 threads=5
      WSGIScriptAlias / /var/www/fizzbuzz/index.wsgi

      <Directory /var/www/fizzbuzz>
          WSGIProcessGroup fizzbuzz
          WSGIApplicationGroup %{GLOBAL}
          Require all granted
      </Directory>
  </VirtualHost>
#+END_SRC

Nach einem Neustart des Webservers

#+BEGIN_SRC sh
sudo service apache2 restart
#+END_SRC

ist die Seite unter der URL http://localhost/fizzbuzz/20 erreichbar.

* In git-repo einchecken

Ein typischer Ablauf wird z.B. bei [[https://guides.github.com/introduction/flow/][github]] vorgestellt.

#+BEGIN_SRC sh -n :results output
  # Ein Verzeichnis erstellen und den Quelltext kopieren/erstellen
  mkdir /tmp/fizzbuzz_repo
  cd /tmp/fizzbuzz_repo
  echo 'print("Hallo Welt")' > hallo.py

  # Repo initialisieren
  git init

  # Dateien für commit vormerken
  git add hallo.py

  # Dateien in Repo einchecken
  git commit -m "commit hallo.py" hallo.py

  # Logfile anschauen
  git log

  # Feature branch erzeugen und wechseln
  git checkout -b new_feature

  # Dateien ändern
  echo 'print("new feature")' >> hallo.py

  # Einen Commit im neuen Branch erzeugen
  git commit -m "added new feature" hallo.py

  # Zurück zum Hauptbranch wechseln
  git checkout master

  # Feature-Branch in den Hauptzweig integrieren
  git merge new_feature

  # Wenn alles geklappt hat, kann der Feature Branch gelöscht werden
  git branch -d new_feature

#+END_SRC

#+RESULTS:
#+begin_example
Initialisierte leeres Git-Repository in /tmp/fizzbuzz_repo/.git/
[master (Basis-Commit) 18b15bf] commit hallo.py
 1 file changed, 1 insertion(+)
 create mode 100644 hallo.py
commit 18b15bf89bdc33e400f52c0acfcaacf26006ebea
Author: Marco Bakera <marco@bakera.de>
Date:   Sat Apr 29 13:20:20 2017 +0200

    commit hallo.py
[new_feature 11ca286] added new feature
 1 file changed, 1 insertion(+)
Aktualisiere 18b15bf..11ca286
Fast-forward
 hallo.py | 1 +
 1 file changed, 1 insertion(+)
Branch new_feature entfernt (war 11ca286).
#+end_example

* Als installierbares Programm

Zunächst muss eine Datei =setup.py= angelegt werden. Sie könnte
folgenden Inhalt haben:

#+INCLUDE: "setup.py" src python -n

Das Programm kann dann mit folgenden Befehlen installiert oder
erstellt werden:

#+BEGIN_SRC sh -n :results output
  # Release in Unterordner erstellen: 
  python setup.py sdist
#+END_SRC

#+RESULTS:
#+begin_example
running sdist
running egg_info
writing dependency_links to fizzbuzz_katas.egg-info/dependency_links.txt
writing fizzbuzz_katas.egg-info/PKG-INFO
writing top-level names to fizzbuzz_katas.egg-info/top_level.txt
reading manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
writing manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
running check
creating fizzbuzz_katas-0.1
creating fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
making hard links in fizzbuzz_katas-0.1...
hard linking setup.py -> fizzbuzz_katas-0.1
hard linking fizzbuzz_katas.egg-info/PKG-INFO -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
hard linking fizzbuzz_katas.egg-info/SOURCES.txt -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
hard linking fizzbuzz_katas.egg-info/dependency_links.txt -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
hard linking fizzbuzz_katas.egg-info/top_level.txt -> fizzbuzz_katas-0.1/fizzbuzz_katas.egg-info
Writing fizzbuzz_katas-0.1/setup.cfg
Creating tar archive
removing 'fizzbuzz_katas-0.1' (and everything under it)
#+end_example

Anschließend kann das Paket (lokal) installiert werden.

#+BEGIN_SRC sh -n :results output
  # Systemweite Installation:
  python setup.py install

  # Lokale Installation:
  #python setup.py install --user
#+END_SRC

#+RESULTS:
#+begin_example
running install
running bdist_egg
running egg_info
writing fizzbuzz_katas.egg-info/PKG-INFO
writing top-level names to fizzbuzz_katas.egg-info/top_level.txt
writing dependency_links to fizzbuzz_katas.egg-info/dependency_links.txt
reading manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
writing manifest file 'fizzbuzz_katas.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
creating build/bdist.linux-x86_64/egg
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/PKG-INFO -> build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/SOURCES.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/dependency_links.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying fizzbuzz_katas.egg-info/top_level.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
creating 'dist/fizzbuzz_katas-0.1-py3.5.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing fizzbuzz_katas-0.1-py3.5.egg
Removing /media/marco/2e2c3431-cdb2-4a34-bc6a-f263678c5740/home/marco/proj/fizzbuzz/fizzbuzz-ve/lib/python3.5/site-packages/fizzbuzz_katas-0.1-py3.5.egg
Copying fizzbuzz_katas-0.1-py3.5.egg to /media/marco/2e2c3431-cdb2-4a34-bc6a-f263678c5740/home/marco/proj/fizzbuzz/fizzbuzz-ve/lib/python3.5/site-packages
fizzbuzz-katas 0.1 is already the active version in easy-install.pth

Installed /media/marco/2e2c3431-cdb2-4a34-bc6a-f263678c5740/home/marco/proj/fizzbuzz/fizzbuzz-ve/lib/python3.5/site-packages/fizzbuzz_katas-0.1-py3.5.egg
Processing dependencies for fizzbuzz-katas==0.1
Finished processing dependencies for fizzbuzz-katas==0.1
#+end_example

* Als getestetes Programm (mit unittest und doctests)

Bei einem UnitTest testet eine Testklasse die Methoden einer anderen
Klasse und prüft einen erhaltenen Ist-Wert gegen den erwarteten
Soll-Wert. In Python geschiet dies über das Paket [[https://docs.python.org/3/library/unittest.html][unittest]].

#+BEGIN_SRC python -n :results output :cache yes
  import unittest

  class FizzBuzz:
      def fizzbuzz(self, i):
          if i % 3 == 0 and i % 5 == 0:
              return "fizzbuzz"
          elif i % 3 == 0:
              return "fizz"
          elif i % 5 == 0:
              return "buzz"
          else:
              return i

  class FizzBuzzTest(unittest.TestCase):
      """This test class tests the class FizzBuzz. 

      Possible input will be testet against desired outputs."""

      def setUp(self):
          """Will be invoked before every test."""
          self.fizzbuzz = FizzBuzz()
      
      def test_fizzbuzz(self):
          fb = self.fizzbuzz

          # Comparing values
          self.assertEqual(fb.fizzbuzz(2), 2)
          self.assertEqual(fb.fizzbuzz(15), "fizzbuzz")
          self.assertEqual(fb.fizzbuzz(9), "fizz")
          self.assertEqual(fb.fizzbuzz(10), "buzz")

          # Boolean comparison
          self.assertTrue(fb.fizzbuzz(12) != 12)
          self.assertFalse(fb.fizzbuzz(12) == 12)

          # Comparing types
          self.assertIsInstance(fb.fizzbuzz(2), int)

          # Comparing with collections
          for i in range(20):
              result = fb.fizzbuzz(i)            
              self.assertIn(result, ['fizz', 'buzz', 'fizzbuzz', i])

  def run_unit_tests():
      # Run all unit tests
      unittest.main()

  run_unit_tests()

#+END_SRC

#+RESULTS[80916782c7749f32280c40953cf2dce9cb75af45]:

Die Tests können bei Python auch direkt in den Kommentaren stehen. In
diesem Fall spricht man von einem [[https://docs.python.org/3/library/doctest.html][doctest]]. Die Zeichen "=>>>="
beschreiben die Eingabe, direkt darunter kommt die erwartete Ausgabe.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import doctest

  class FizzBuzz:
      def fizzbuzz(self, i):
          """This is a comment containing a test. This is called a doctest in Python.

          >>> fb = FizzBuzz()
          >>> fb.fizzbuzz(3)
          'fizz'
          >>> fb.fizzbuzz(5)
          'buzz'
          >>> fb.fizzbuzz(10)
          'buzz'
          >>> fb.fizzbuzz(11)
          11

          Now a test that creates an error:

          >>> fb.fizzbuzz(12)
          12

          """
          if i % 3 == 0 and i % 5 == 0:
              return "fizzbuzz"
          elif i % 3 == 0:
              return "fizz"
          elif i % 5 == 0:
              return "buzz"
          else:
              return i

  def run_doc_tests():
      doctest.testmod()

  run_doc_tests()
#+END_SRC

#+RESULTS[755ee17eef7fcc15966a21af1f8e5d1df29c50cc]:
#+begin_example
**********************************************************************
File "<stdin>", line 19, in __main__.FizzBuzz.fizzbuzz
Failed example:
    fb.fizzbuzz(12)
Expected:
    12
Got:
    'fizz'
**********************************************************************
1 items had failures:
   1 of   6 in __main__.FizzBuzz.fizzbuzz
***Test Failed*** 1 failures.
#+end_example

* Mit einem EA-Modul ansteuern

#+attr_html: :width 500px
file:doc/ea_modul_an_pi.jpg

Die Bibliothek =eapi= (https://github.com/pintman/ea_rpi_modul) kann
über =pip= installiert werden.

#+BEGIN_SRC sh
pip install eapi
#+END_SRC

Nun kann es verwendet werden. Die wichtigste Klasse ist
=eapi.hw.EAModul=.

#+BEGIN_SRC python -n

  import eapi.hw 

  class FizzBuzzEAModul:
      def __init__(self):
          self.i = 0

          eam = eapi.hw.EAModul()
          # switching on green LED only
          eam.schalte_leds(False, False, True)
          # register for events when button0 pressed
          eam.taster_event_registrieren(0, self.taster0_gedrueckt)

          # wait for taster event
          while True:
              pass

      def taster0_gedrueckt(self, pin):
          if self.i % 3 == 0 and self.i % 5 == 0:
              print("fizzbuzz")
          elif self.i % 3 == 0:
              print("fizz")
          elif self.i % 5 == 0:
              print("buzz")
          else:
              print(self.i)

          self.i += 1

  FizzBuzzEAModul()

#+END_SRC

#+RESULTS:

Eine Hilfe zu dem Modul lässt sich über pydoc abrufen.

#+BEGIN_SRC sh :results output :exports both :cache yes
python -m pydoc eapi.hw.EAModul
#+END_SRC

#+RESULTS[071b7056b27e45c1db8d2d5613275e14cc7870ba]:
#+begin_example
Help on class EAModul in eapi.hw:

eapi.hw.EAModul = class EAModul(builtins.object)
 |  Die Klasse EAModul hilft bei der Ansteuerung eines Eingabe-Ausgabe-Moduls
 |  für den Raspberry Pi. Es besteht aus drei LED und zwei Tastern.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, pin_taster0=29, pin_taster1=31, pin_led_rot=33, pin_led_gelb=35, pin_led_gruen=37)
 |      Das Modul wird mit den gegebenen Pins konfiguriert.
 |      
 |      Pins der LEDs werden als Ausgänge und Pins der Taster als Eingänge
 |      konfiguriert. Wenn keine PINS angegeben werden, werden die PINs
 |      oberhalb des GND Pins links unten verwendet.
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      Wenn keine Werte angegeben werden, werden die Standard-Pins verwendet.
 |      
 |      >>> ea1 = EAModul()
 |      >>> ea1.cleanup()
 |      
 |      Bei einer abweichenden Verdrahtung können die Pins angegeben werden.
 |      
 |      >>> ea2 = EAModul(29, 31, 33, 35, 37)
 |      
 |      Um den Quelltext übersichtlicher zu gestalten, können die Pins
 |      direkt bezeichnet werden.
 |      
 |      >>> ea2 = EAModul(pin_taster0=29, pin_taster1=31, pin_led_rot=33,
 |      ...               pin_led_gelb=35, pin_led_gruen=37)
 |      >>> ea2.cleanup()
 |  
 |  cleanup(self)
 |      Setzt alle Pins des Pi wieder in den Ausgangszustand.
 |      
 |      >>> from eapi.hw import EAModul
 |      >>> ea = EAModul()
 |      >>> ea.cleanup()
 |  
 |  led_event_registrieren(self, led_farbe, methode)
 |      Registriert eine Methode, die ausgeführt wird, sobald die
 |      entsprechende LED ihren Wert ändert.
 |      
 |      Die Methode wird über alle Veränderungen an der LED informiert. Dazu
 |      wird die übergebene Methode aufgerufen.
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      >>> def update_rote_led(neuer_wert):
 |      ...    print("update: Status der roten LED hat sich geändert.")
 |      ...    print("Neuer Wert:", neuer_wert)
 |      
 |      >>> ea = EAModul()
 |      >>> ea.led_event_registrieren(EAModul.LED_ROT, update_rote_led)
 |      
 |      Nun wird die Update-Methode aufgerufen, sobald sich der Wert der LED
 |      ändert.
 |      
 |      >>> ea.schalte_led(EAModul.LED_ROT, 1)
 |      update: Status der roten LED hat sich geändert.
 |      Neuer Wert: 1
 |      
 |      >>> ea.schalte_led(EAModul.LED_ROT, 0)
 |      update: Status der roten LED hat sich geändert.
 |      Neuer Wert: 0
 |      
 |      >>> ea.cleanup()
 |  
 |  schalte_led(self, led_farbe, an_aus)
 |      Schalte die LED mit der gegebenen Nummer ein (1) oder aus (0).
 |      
 |      Der Wert für led_farbe ist LED_ROT, LED_GELB oder LED_GRUEN.
 |      
 |      Eine einfache Verwendung könnte wie folgt aussehen:
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      >>> ea_modul = EAModul()
 |      >>> ea_modul.schalte_led(EAModul.LED_ROT, 1)
 |      >>> ea_modul.schalte_led(EAModul.LED_GELB, 0)
 |      >>> ea_modul.schalte_led(EAModul.LED_GRUEN, 1)
 |      >>> ea_modul.cleanup()
 |  
 |  schalte_leds(self, rot_anaus, gelb_anaus, gruen_anaus)
 |      Schalte alle drei LEDs zu gleichen Zeit an oder aus.
 |      
 |      >>> from eapi.hw import EAModul
 |      
 |      >>> ea_modul = EAModul()
 |      >>> ea_modul.schalte_leds(True, False, True)
 |      >>> ea_modul.cleanup()
 |  
 |  taster_event_registrieren(self, taster_nr, methode)
 |      Registriere eine Methode, die bei Betätigung eines Tasters
 |      ausgeführt wird.
 |      
 |      Die übergebene Methode muss ein Argument haben und wird mit der
 |      Pin-Nur des Tasters aufgerufen, sobald der Taster gedrückt 
 |      wird. Eine einfache Verwendung könnte wie folgt aussehen:
 |      
 |      >>> def taster0_gedrueckt(pin):
 |      ...  print("Taster 0 wurde gedrückt.")
 |      
 |      >>> ea_modul = EAModul()
 |      >>> ea_modul.taster_event_registrieren(0, taster0_gedrueckt)
 |      >>> ea_modul.cleanup()
 |  
 |  taster_gedrueckt(self, num=0)
 |      Liest den Wert des Tasters mit der gegebenen Nummer aus und gibt den
 |      Wert zurück. Eine einfache Verwendung könnte wie folgt aussehen:
 |      
 |      >>> from eapi.hw import EAModul
 |      >>> import time
 |      
 |      >>> ea_modul = EAModul()
 |      >>> while not ea_modul.taster_gedrueckt(1):
 |      ...   ea_modul.schalte_led(EAModul.LED_ROT, 1)
 |      ...   time.sleep(0.2)
 |      ...   ea_modul.schalte_led(EAModul.LED_ROT, 0)
 |      >>> ea_modul.cleanup()
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  LED_GELB = 1
 |  
 |  LED_GRUEN = 2
 |  
 |  LED_ROT = 0

#+end_example

** TODO Beispiel mit gpiozero ergänzen 				   :noexport:
   
* Mit Anbindung an eine Datenbank

#+BEGIN_SRC python -n :results output :cache yes

import sqlite3

def fizzbuzz_insert_into_db():
    conn = sqlite3.connect("fizzbuzz.db")
    c = conn.cursor()
    c.execute("CREATE TABLE IF NOT EXISTS fizzbuzz(nr int, ergebnis text)")

    for i in range(20):
        erg = ""
        if i % 3 == 0 and i % 5 == 0:
            erg = "fizzbuzz"
        elif i % 3 == 0:
            erg = "fizz"
        elif i % 5 == 0:
            erg = "buzz"
        else:
            erg = i

        c.execute("INSERT INTO fizzbuzz VALUES(?,?)", (i,erg))

    conn.commit()
    conn.close()

def fizzbuzz_select_from_db():
    conn = sqlite3.connect("fizzbuzz.db")
    c = conn.cursor()
    rows = c.execute("SELECT nr, ergebnis FROM fizzbuzz")

    print("Nr.\tErgebnis")
    for i,erg in rows:
        print(i, "    ", erg)

    conn.close()

fizzbuzz_insert_into_db()
fizzbuzz_select_from_db()
#+END_SRC

#+RESULTS[f98d739032eb8ea2eca501d6758ddc8c12070d66]:
#+begin_example
Nr.	Ergebnis
0      fizzbuzz
1      1
2      2
3      fizz
4      4
5      buzz
6      fizz
7      7
8      8
9      fizz
10      buzz
11      11
12      fizz
13      13
14      14
15      fizzbuzz
16      16
17      17
18      fizz
19      19
#+end_example

Nach dem Versuch entsteht eine Datei =fizzbuzz.db=, die man mit
=sqlite= befragen oder auch einfach kopieren und löschen kann.

#+BEGIN_SRC sh
rm fizzbuzz.db
#+END_SRC

#+RESULTS:

* Mit docstring Dokumentation
#+BEGIN_SRC python -n :results output :exports both :cache yes
  class FizzBuzzGame:
      """A class for a fizzbuzz game."""
      
      def fizzbuzz_documented(n):
          """This method runs through all numbers from 0 to n-1.  

          It prints 'fizz' if the number is divisible by 3, 'buzz' if it
          is divisble by 5, 'fizzbuzz' if it is divisible 3 and 5 and
          the number itseld otherwise.
          """

          for i in range(n):
              if i % 3 == 0 and i % 5 == 0:
                  print("fizzbuzz")
              elif i % 3 == 0:
                  print("fizz")
              elif i % 5 == 0:
                  print("buzz")
              else:
                  print(i)

  help(FizzBuzzGame)
#+END_SRC

#+RESULTS[dc976453b9072344005b4088cb09785e4e845df1]:
#+begin_example
Help on class FizzBuzzGame in module __main__:

class FizzBuzzGame(builtins.object)
 |  A class for a fizzbuzz game.
 |  
 |  Methods defined here:
 |  
 |  fizzbuzz_documented(n)
 |      This method runs through all numbers from 0 to n-1.  
 |      
 |      It prints 'fizz' if the number is divisible by 3, 'buzz' if it
 |      is divisble by 5, 'fizzbuzz' if it is divisible 3 and 5 and
 |      the number itseld otherwise.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

#+end_example

Der Kommentar einer Methode oder Klasse steht immer als erster
String in der Deklaration.

Er kann im Python-Interpreter mit =help()= abgerufen werden:

Außerdem gibt es das Modul =pydoc=, mit dem eine Dokumentation auf der
Kommandozeile oder über einen Webserver zur Verfügung steht.

#+BEGIN_SRC sh
pydoc3 fizzbuzz.fizzbuzz_dokumentiert
python -m pydoc fizzbuzz.fizzbuzz_dokumentiert
#+END_SRC

#+RESULTS:
: problem in fizzbuzz - ImportError: No module named 'sopel'

Webserver starten auf Port 8080 mit Dokumentation unter
http://localhost:8080

#+BEGIN_SRC sh
pydoc -p 8080

# alternativ:
python -m pydoc -p 8080
#+END_SRC

* Als Chatbot 

Wir verwenden hier sopel als Web-Framework (https://sopel.chat/ und
https://github.com/sopel-irc/sopel/wiki).

Installation
#+BEGIN_SRC sh :results output
pip install sopel
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): sopel in ./fizzbuzz-ve/lib/python3.5/site-packages
: Requirement already satisfied (use --upgrade to upgrade): xmltodict in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): pytz in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): praw in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): pyenchant in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): pygeoip in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): requests<2.11.0,>=2.0.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from sopel)
: Requirement already satisfied (use --upgrade to upgrade): update-checker>=0.16 in ./fizzbuzz-ve/lib/python3.5/site-packages (from praw->sopel)
: Requirement already satisfied (use --upgrade to upgrade): prawcore<0.9,>=0.8.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from praw->sopel)


Konfiguration (in =~/.sopel=) erstellen: 
#+BEGIN_SRC sh
sopel
#+END_SRC

Nach ein paar Fragen könnte die Konfiguration wie folgt aussehen.

#+INCLUDE: "~/.sopel/fizzbuzz.cfg" src sh -n

Eigenen Bot in =~/.sopel/modules/fizzbuzz.py= erstellen

#+BEGIN_SRC python -n
from sopel import module

@module.commands('fizzbuzz')
def echo(bot, trigger):
    # to everybody:   bot.say("...")
    # to questioner: bot.reply("...")

    # take and convert argument
    i = int(trigger.group(2))

    if i % 3 == 0 and i % 5 == 0:
        bot.reply("fizzbuzz")
    elif i % 3 == 0:
        bot.reply("fizz")
    elif i % 5 == 0:
        bot.reply("buzz")
    else:
        bot.reply(i)
#+END_SRC

Sopel starten
#+BEGIN_SRC sh
sopel
#+END_SRC
           
Eine mögliche Chat-Konversation (Sopel-Befehle beginnen mit einem
Punkt):

#+BEGIN_EXAMPLE
= FizzBuzzBot has joined
<fizzbuzz_owner> .fizzbuzz 1
<FizzBuzzBot>    fizzbuzz_owner: 1
<fizzbuzz_owner> .fizzbuzz 2
<FizzBuzzBot>    fizzbuzz_owner: 2
<fizzbuzz_owner> .fizzbuzz 3
<FizzBuzzBot>    fizzbuzz_owner: fizz
<fizzbuzz_owner> .fizzbuzz 5
<FizzBuzzBot>    fizzbuzz_owner: buzz
<fizzbuzz_owner> .fizzbuzz 14
<FizzBuzzBot>    fizzbuzz_owner: 14
<fizzbuzz_owner> .fizzbuzz 15
<FizzBuzzBot>    fizzbuzz_owner: fizzbuzz
#+END_EXAMPLE

** TODO XMPP-Bot Beispiel 					   :noexport:
z.B. https://dev.gajim.org/gajim/python-nbxmpp/

oder errbot.op: http://errbot.io/en/latest/features.html

https://github.com/fritzy/SleekXMPP Beispiel aus einem OReilly Buch

Die Bibliothek [[https://github.com/fritzy/SleekXMPP][SleekXMPP]] kann über einen Paket-Manager der
Distribution oder =pip= installiert werden.

#+BEGIN_SRC sh :results output
# via package manager
# sudo apt install python3-sleekxmpp

# via pip
pip install sleekxmpp
#+END_SRC


#+BEGIN_SRC python -n
  import logging

  from sleekxmpp import ClientXMPP
  from sleekxmpp.exceptions import IqError, IqTimeout

  class EchoBot(ClientXMPP):

      def __init__(self, jid, password):
          super().__init__(self, jid, password)

          self.add_event_handler("session_start", self.session_start)
          self.add_event_handler("message", self.message)

          # If you wanted more functionality, here's how to register plugins:
          # self.register_plugin('xep_0030') # Service Discovery
          # self.register_plugin('xep_0199') # XMPP Ping

          # Here's how to access plugins once you've registered them:
          # self['xep_0030'].add_feature('echo_demo')

          # If you are working with an OpenFire server, you will
          # need to use a different SSL version:
          # import ssl
          # self.ssl_version = ssl.PROTOCOL_SSLv3

      def session_start(self, event):
          self.send_presence()
          self.get_roster()

          # Most get_*/set_* methods from plugins use Iq stanzas, which
          # can generate IqError and IqTimeout exceptions
          #
          # try:
          #     self.get_roster()
          # except IqError as err:
          #     logging.error('There was an error getting the roster')
          #     logging.error(err.iq['error']['condition'])
          #     self.disconnect()
          # except IqTimeout:
          #     logging.error('Server is taking too long to respond')
          #     self.disconnect()

      def message(self, msg):
          if msg['type'] in ('chat', 'normal'):
              msg.reply("Thanks for sending\n%(body)s" % msg).send()

          i = int(msg.body)
          if i % 3 == 0 and i % 5 == 0:
              msg.reply("fizzbuzz").send()
          elif i % 3 == 0:
              msg.reply("fizz").send()
          elif i % 5 == 0:
              msg.reply("buzz").send()
          else:
              msg.reply(str(i)).send)()

              

  if __name__ == '__main__':
      # Ideally use optparse or argparse to get JID,
      # password, and log level.

      logging.basicConfig(level=logging.DEBUG,
                          format='%(levelname)-8s %(message)s')

      xmpp = EchoBot('somejid@example.com', 'use_getpass')
      xmpp.connect()
      xmpp.process(block=True)
#+END_SRC

* Auf einem Cluster (mit GNU parallel)

Hierfür bedienen wir uns des Programmes GNU parallel. Es muss auf dem
Rechner installiert sein oder lässt sich unter Ubuntu leicht nachinstallieren.

#+BEGIN_SRC 
sudo apt-get install parallel
#+END_SRC

Wir nutzen die folgende Datei =fizzbuzz.py=.

#+BEGIN_SRC python -n
  import sys

  def fizzbuzz_cluster():
      i = int (sys.argv[1])

      if i % 3 == 0 and i % 5 == 0:
          print(i, "fizzbuzz")
      elif i % 3 == 0:
          print(i, "fizz")
      elif i % 5 == 0:
          print(i, "buzz")
      else:
          print(i, i)

  fizzbuzz_cluster()
#+END_SRC

Zuerst muss die Datei =fizzbuzz.py= auf jeden Rechner im Cluster
übertragen werden und der ssh-login gemäß der Beschreibung in =man
parallel= eingerichtet worden sein. Dies wird im Abschnitt "EXAMPLE:
Using remote computers" der man-page beschrieben.

Nun folgt der Aufruf:

#+BEGIN_SRC sh
seq 20 | parallel --sshlogin server1,server2,server3 python3 fizzbuzz.py
#+END_SRC

=seq 20= generiert die Zahlen 1 bis 20 und sendet sie über eine Pipe (=|=)
an den Befehl =parallel=. Dieser verteilt die Aufrufe

- =python3 fizzbuzz.py 1=,
- =python3 fizzbuzz.py 2=,
- =python3 fizzbuzz.py 3=,
- =python3 fizzbuzz.py 4=',

auf die Server server1, server2 und server3.

* In einem UML-Aktivitätsdiagramm

#+BEGIN_SRC plantuml :file doc/fizzbuzz-aktdiag.png :cache yes
@startuml
start
:zahl = 1;
while (zahl <= 20) is (ja)

if (zahl mod 3 == 0 und zahl mod 5 == 0) then (ja)
    :Ausgabe "fizzbuzz";
else (nein)
    if (zahl mod 3 == 0) then (ja)
        :Ausgabe "fizz";
    else (nein)
    	if (zahl mod 5 == 0) then (ja)
      	    :Ausgabe "buzz";
        else (nein)
	    :Ausgabe zahl;
	endif
    endif
endif
  
:zahl = zahl +1;
  
endwhile  (nein)

stop

@enduml
#+END_SRC

#+RESULTS[7bf18c2091416d56db25e7fd95f57a3963107119]:
[[file:doc/fizzbuzz-aktdiag.png]]

* In einem UML-Sequenzdiagramm

Der FizzbuzzServer hat eine Methode =fizzbuzz(zahl: int): answer=, die
von einem Client mit einer Zahl aufgerufen werden kann. Die Antwort
ist eine Zahl oder ein String.

#+BEGIN_SRC plantuml :file doc/fizzbuzz-seqdiag.png :cache yes
@startuml
skinparam sequenceParticipant underline

activate ":Client"
":Client" -> ":FizzbuzzServer": fizzbuzz(2)
activate ":FizzbuzzServer"
":FizzbuzzServer" --> ":Client": 2
deactivate ":FizzbuzzServer"
":Client" -> ":Client": Ausgabe 2

":Client" -> ":FizzbuzzServer": fizzbuzz(3)
activate ":FizzbuzzServer"
":FizzbuzzServer" --> ":Client": "fizz"
deactivate ":FizzbuzzServer"
":Client" -> ":Client": Ausgabe "fizz"

":Client" -> ":FizzbuzzServer": fizzbuzz(5)
activate ":FizzbuzzServer"
":FizzbuzzServer" --> ":Client": "buzz"
deactivate ":FizzbuzzServer"
":Client" -> ":Client": Ausgabe "buzz"

":Client" -> ":FizzbuzzServer": fizzbuzz(zahl)
activate ":FizzbuzzServer"

note left: Nun der allgemeine Fall
alt zahl % 3 == 0 and zahl % 5 == 0
    ":FizzbuzzServer" --> ":Client": "fizzbuzz"
    ":Client" -> ":Client": Ausgabe "fizzbuzz"
else zahl % 3 == 0
    ":FizzbuzzServer" --> ":Client": "fizz"
    ":Client" -> ":Client": Ausgabe "fizz"
else zahl % 5 == 0
    ":FizzbuzzServer" --> ":Client": "buzz"
    ":Client" -> ":Client": Ausgabe "buzz"
else sonst
    ":FizzbuzzServer" --> ":Client": zahl
    ":Client" -> ":Client": Ausgabe zahl
end
deactivate ":FizzbuzzServer"

@enduml
#+END_SRC

#+RESULTS[e8dd3925834077bb61b47aaef123a77ed2e7df2f]:
[[file:doc/fizzbuzz-seqdiag.png]]

* In einem UML-Klassendiagramm

file:doc/fizzbuzz_klassendiagramm.png

Attribute und Methoden sind mit einer /Sichtbarkeit/ (+=public
(überall zugreifbar), #=protected (aus der Klasse selbst und
Kindklassen zugreifbar), -=private (nur aus der Klasse selbst
zugreifbar)) und einem /Rückgabewert bzw. Typ/ gekennzeichnet.

Dies Klasse könnte wie folgt verwendet werden.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  class FizzBuzzGame:
      def __init__(self, n):
          # protected/private attributes are marked with one/two underscores
          self.__number = n

      def fizzbuzz(self):
          if self.__number % 3 == 0 and self.__number % 5 == 0:
              return "fizzbuzz"
          elif self.__number % 3 == 0:
              return "fizz"
          elif self.__number % 5 == 0:
              return "buzz"
          else:
              return self.__number

  fb = FizzBuzzGame(2)
  print("Eingabe:", 2, "Ausgabe:", fb.fizzbuzz())
  fb = FizzBuzzGame(15)
  print("Eingabe:", 15, "Ausgabe:", fb.fizzbuzz())
#+END_SRC

#+RESULTS[ec4a8a8a3aacfd23d09b3efecffeb862dd26a64c]:
: Eingabe: 2 Ausgabe: 2
: Eingabe: 15 Ausgabe: fizzbuzz

Da es sich bei fizzbuzz um ein Spiel handelt, bietet es sich an,
Vererbung an dieser Stelle zu nutzen. Der Pfeil zwischen den Klassen
wird in Pfeilrichtung als "ist ein" gelesen.

file:doc/fizzbuzz_klassendiagramm-vererbung.png

Da das Spiel gewöhnlich von einem Spieler gespielt wird, kann dies als
eine "hat"-Beziehung durch eine [[https://de.wikipedia.org/wiki/Assoziation_(UML)#Aggregation_und_Komposition][Aggregation-Beziehung]] mit einer nicht
ausgefüllten Raute dargestellt werden.

file:doc/fizzbuzz_klassendiagramm-komp-aggr.png

* Als IOT-Anwendung mit einem Message-Broker (MQTT)

[[https://de.wikipedia.org/wiki/MQTT][MQTT]] ist ein u.a. von IBM entwickeltes offenes Protokoll, das auf Port
1883 und 8883 (mit Verschlüsselung) läuft und für die Übertragung von
Sensordaten zwischen Maschinen entwickelt wurde. Ein [[https://heise.de/-2168152][Artikel bei heise]]
und ein [[https://dzone.com/articles/mqtt-the-nerve-system-of-iot][Artikel bei dzone]] beschreiben das Protokoll ausführlich.

Als Client-Bibliothek wird [[https://pypi.python.org/pypi/paho-mqtt/][paho-mqtt]] verwendet. Diese lässt sich
einfach installieren.

#+BEGIN_SRC sh
pip install --user paho-mqtt
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): paho-mqtt in ./fizzbuzz-ve/lib/python3.5/site-packages

Eine mögliche Kommunikation zwischen zwei Clients und dem Broker.

#+BEGIN_SRC plantuml :file doc/fizzbuzz-mqtt.png :cache yes
@startuml
subscriber -> Broker: connect()
publisher -> Broker: connect()

subscriber -> Broker: subscribe("fizzbuzz/")
publisher -> Broker: publish("fizzbuzz/", "2")
Broker -> subscriber: on_message(2)
subscriber -> subscriber: print(2)

publisher -> Broker: publish("fizzbuzz/", "3")
Broker -> subscriber: on_message(3)
subscriber -> subscriber: print("fizz")

publisher -> Broker: publish("falscher_kanal/", "2")

@enduml
#+END_SRC

#+RESULTS[727e051b35e673ad3e2a799f958d9f0cc7da8039]:
[[file:doc/fizzbuzz-mqtt.png]]


#+BEGIN_SRC python -n :results output :exports both :cache yes
  import paho.mqtt.client as mqtt
  import threading
  import time

  class FizzbuzzPublisher:
      def __init__(self, server="iot.eclipse.org", port=1883):
          self.client = mqtt.Client()
          self.client.connect(server, port, keepalive=60)
      
      def publish(self, payload):
          print("[publish]", payload)
          self.client.publish("fizzbuzz/", payload)

          
  class FizzbuzzSubscriber:
      def __init__(self, server="iot.eclipse.org", port=1883):
          self.client = mqtt.Client()
          self.client.on_connect = self.on_connect
          self.client.on_message = self.on_message
          self.client.connect(server, port, keepalive=60)

      def start(self):
          self.client.loop_forever()

      def on_connect(self, client, userdata, flags, rc):
          print("[connected]")
          self.client.subscribe("fizzbuzz/")
      
      def on_message(self, client, userdata, msg):
          i = int(msg.payload)
          
          if i % 3 == 0 and i % 5 == 0:
              answer = "fizzbuzz"
          elif i % 3 == 0:
              answer = "fizz"
          elif i % 5 == 0:
              answer = "buzz"
          else:
              answer = i

          print("[msg reveived] topic:", msg.topic, "payload:", i, "answer:", answer)


  #### Subscriber ####
          
  # Start thread in background that responds to messages
  print("[subscribing]")
  sub = FizzbuzzSubscriber()
  th1 = threading.Thread(target=sub.start, daemon=True)
  th1.start()

  #### Publisher ####

  print("[start publishing]")
  pub = FizzbuzzPublisher()
  for i in range(1,21):
      pub.publish(i)
      # waiting some time and give the subscribed client time to do the job.
      time.sleep(0.1)

  time.sleep(1)

#+END_SRC

#+RESULTS[74b3dfeeb0156d002cf9f2721a9733b0c8d945f2]:
#+begin_example
[subscribing]
[start publishing]
[publish] 1
[connected]
[publish] 2
[publish] 3
[publish] 4
[msg reveived] topic: fizzbuzz/ payload: 1 answer: 1
[msg reveived] topic: fizzbuzz/ payload: 2 answer: 2
[publish] 5
[publish] 6
[publish] 7
[publish] 8
[publish] 9
[publish] 10
[msg reveived] topic: fizzbuzz/ payload: 3 answer: fizz
[publish] 11
[msg reveived] topic: fizzbuzz/ payload: 4 answer: 4
[msg reveived] topic: fizzbuzz/ payload: 5 answer: buzz
[msg reveived] topic: fizzbuzz/ payload: 6 answer: fizz
[msg reveived] topic: fizzbuzz/ payload: 7 answer: 7
[msg reveived] topic: fizzbuzz/ payload: 8 answer: 8
[msg reveived] topic: fizzbuzz/ payload: 9 answer: fizz
[publish] 12
[msg reveived] topic: fizzbuzz/ payload: 10 answer: buzz
[publish] 13
[publish] 14
[msg reveived] topic: fizzbuzz/ payload: 11 answer: 11
[msg reveived] topic: fizzbuzz/ payload: 12 answer: fizz
[publish] 15
[msg reveived] topic: fizzbuzz/ payload: 13 answer: 13
[publish] 16
[msg reveived] topic: fizzbuzz/ payload: 14 answer: 14
[publish] 17
[publish] 18
[msg reveived] topic: fizzbuzz/ payload: 15 answer: fizzbuzz
[msg reveived] topic: fizzbuzz/ payload: 16 answer: 16
[publish] 19
[msg reveived] topic: fizzbuzz/ payload: 17 answer: 17
[publish] 20
[msg reveived] topic: fizzbuzz/ payload: 18 answer: fizz
[msg reveived] topic: fizzbuzz/ payload: 19 answer: 19
[msg reveived] topic: fizzbuzz/ payload: 20 answer: buzz
#+end_example

Das obige Beispiel nutzt einen Testserver unter der Adresse
=iot.eclipse.org=. Bei github gibt es eine [[https://github.com/mqtt/mqtt.github.io/wiki/servers][Übersicht mit MQTT
Servern]].

Das folgende Beispiel verwendet das EA-Modul. 

Hierbei agiert ein Taster als Sensor, der beim Drücken in das Topic
=eamodul/taster0/pressed= eine 1 sendet. 

Eine LED agiert als Sensor, die sich beim Topic registriert und auf
Nachrichten entsprechend reagiert: Wenn die Zahl durch 3 bzw. 5
teilbar ist, geht die gelbe bzw. rote LED an, ansonsten leuchtet nur
die grüne LED.

#+BEGIN_SRC plantuml :file doc/fizzbuzz-mqtt-eamodul.png :cache yes
@startuml 
mqtt_modul -> Broker: connect()
Broker -> mqtt_modul: on_connect()
mqtt_modul -> Broker: subscribe("eamodul/taster0/pressed/")


loop 2-mal
note right: Taster wird zweimal gedrückt.
ea_modul -> mqtt_modul: taster_gedrueckt()
mqtt_modul -> Broker: publish("eamodul/taster0/pressed/", "1")
Broker -> mqtt_modul: on_message(1)
mqtt_modul -> ea_modul: schalte_leds(False, False, False)

mqtt_modul -> ea_modul: schalte_led(gruen, True)
end

ea_modul -> mqtt_modul: taster_gedrueckt()
note right 
  Beim dritten Drücken 
  leuchtet die grüne LED.
endnote

mqtt_modul -> Broker: publish("eamodul/taster0/pressed/", "1")
Broker -> mqtt_modul: on_message(1)
mqtt_modul -> ea_modul: schalte_leds(False, False, False)

mqtt_modul -> ea_modul: schalte_led(gelb, True)

@enduml
#+END_SRC

#+RESULTS[dfb4deff4c4c988b0f2edd0864611a87804dd6e3]:
[[file:doc/fizzbuzz-mqtt-eamodul.png]]

Es folgt der Quelltext.

#+INCLUDE: "fizzbuzz_mqtt_eamodul.py" src python -n

* Mit Kommandozeilenparametern

Kommandozeilenparameter stehen in =sys.argv=.

#+INCLUDE: "fizzbuzz-cli.py" src python -n

Aufruf mit einem Parameter:

#+BEGIN_SRC sh :results output :exports both :cache yes
python fizzbuzz-cli.py 20
#+END_SRC

#+RESULTS[b5b05a43541d82fb48b9e5d7821951fe87ebb0a5]:
#+begin_example
Evaluating command line: ['fizzbuzz-cli.py', '20']
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

Mit dem Paket =argparse=
(https://docs.python.org/3/library/argparse.html) wird die Auswertung
von Kommandozeilenparametern manchmal vereinfacht.

#+INCLUDE: "fizzbuzz-argparse.py" src python -n

Nun steht eine Hilfe zur Verfügung:

#+BEGIN_SRC sh :results output :exports both :cache yes
python fizzbuzz-argparse.py --help
#+END_SRC

#+RESULTS[b2b9fcc4d34f2f2f088b9e97049f5f10337af69a]:
: usage: fizzbuzz-argparse.py [-h] [--max_wert MAX_WERT]
: 
: FizzBuzz Spiel
: 
: optional arguments:
:   -h, --help           show this help message and exit
:   --max_wert MAX_WERT  Bis zu diesem Wert wird gezählt

Aufruf mit einem Parameter.

#+BEGIN_SRC sh :results output
python fizzbuzz-argparse.py --max_wert 20
#+END_SRC

#+RESULTS:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Mit einer Konfigurationsdatei

Mit dem Paket =configparser=
(https://docs.python.org/3/library/configparser.html) kann eine
Konfigurationsdatei ausgewertet werden.

Die Datei =fizzbuzz.ini=:

#+INCLUDE: "fizzbuzz.ini" src python -n

Auswerten der Datei:

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import configparser

  def fizzbuzz(n):
      for i in range(n):
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)

  config = configparser.ConfigParser()
  config.read("fizzbuzz.ini")

  description = config["informationen"]["beschreibung"]
  print("Beschreibung:", description)

  conf_num = config["default"]["max_wert"]
  num = int(conf_num)
  fizzbuzz(num)


#+END_SRC

#+RESULTS[5349ceadb52b9c296d067f5096a8b0d941338999]:
#+begin_example
Beschreibung: Ein Zählspiel
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

* Als Web-Service mit REST-API

=hug= (http://www.hug.rest/) stellt eine einfache Schnittstelle für
REST-Web-Services bereit.

#+BEGIN_SRC sh :results output
pip install hug
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): hug in ./fizzbuzz-ve/lib/python3.5/site-packages
: Requirement already satisfied (use --upgrade to upgrade): falcon==1.0.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from hug)
: Requirement already satisfied (use --upgrade to upgrade): requests in ./fizzbuzz-ve/lib/python3.5/site-packages (from hug)
: Requirement already satisfied (use --upgrade to upgrade): python-mimeparse in ./fizzbuzz-ve/lib/python3.5/site-packages (from falcon==1.0.0->hug)
: Requirement already satisfied (use --upgrade to upgrade): six>=1.4.0 in ./fizzbuzz-ve/lib/python3.5/site-packages (from falcon==1.0.0->hug)

Ein einfacher Service wird mit der Annotation =@hug.get()=
ausgestattet.

#+INCLUDE: "~/proj/fizzbuzz/fizzbuzz_hug.py" src python -n

Server auf Port 8081 starten:

#+BEGIN_SRC sh 
hug -p 8081 -f fizzbuzz_hug.py
#+END_SRC

#+RESULTS:

Nun kann der Web-Service abgerufen werden (für Tests z.B. mit
curl). Wenn keine korrekte URL angegeben wird, liefert hug eine Hilfe.

#+BEGIN_SRC sh :results output :exports both :cache yes
curl localhost:8081
#+END_SRC

#+RESULTS[af04781cfa76759215e0224901cfc913d06f1a36]:
#+begin_example
{
    "404": "The API call you tried to make was not defined. Here's a definition of the API to help you get going :)",
    "documentation": {
        "handlers": {
            "/fizzbuzz": {
                "GET": {
                    "usage": "Return fizzbuzz up to the given number.",
                    "outputs": {
                        "format": "JSON (Javascript Serialized Object Notation)",
                        "content_type": "application/json"
                    },
                    "inputs": {
                        "max_number": {
                            "type": "Basic text / string value"
                        }
                    }
                }
            }
        }
    }
}
#+end_example

Nun mit einer bekannten URL.

#+BEGIN_SRC sh :results output :exports both :cache yes
curl localhost:8081/fizzbuzz?max_number=10
#+END_SRC

#+RESULTS[817e61e632bf3667e616f7d831d512036707b26b]:
: {"0": "fizzbuzz", "1": 1, "2": 2, "3": "fizz", "4": 4, "5": "buzz", "6": "fizz", "7": 7, "8": 8, "9": "fizz"}

Alternative mit Parameter im Request:

#+BEGIN_SRC sh :results output
curl localhost:8081/fizzbuzz --data max_number=10 --request GET
#+END_SRC

#+RESULTS[8747c8df176c2a6ab70e55e09412c44a2e9a4059]:
: {"0": "fizzbuzz", "1": 1, "2": 2, "3": "fizz", "4": 4, "5": "buzz", "6": "fizz", "7": 7, "8": 8, "9": "fizz"}

* In einer MVC-Architektur

file:doc/mvc.png

[[https://de.wikipedia.org/wiki/Model_View_Controller][Model-View-Controller-Konzept]]. Eine durchgezogene Linie symbolisiert
eine direkte Assoziation, eine gestrichelte eine indirekte Assoziation
(zum Beispiel über einen [[https://de.wikipedia.org/wiki/Beobachter_(Entwurfsmuster)][Beobachter]]).

file:doc/fizzbuzz_mvc.svg

#+BEGIN_SRC python -n :results output :exports both :cache yes
  class FizzBuzzModel:
      def __init__(self):
          self.results = {}

          # a list of observers that react to modifications
          # they must implement a method model_changed(added_value)
          self.observers = []

      def add_value(self, val):        
          if val % 3 == 0 and val % 5 == 0:
              self.results[val] = "fizzbuzz"
          elif val % 3 == 0:
                self.results[val] = "fizz"
          elif val % 5 == 0:
              self.results[val] = "buzz"
          else:
              self.results[val] = val

          self._notify_observers(val)

      def add_observer(self, observer):
          self.observers.append(observer)
          
      def _notify_observers(self, added_val):
          for o in self.observers:
              o.model_changed(added_val)

              
  class FizzBuzzView:
      def __init__(self, model):
          self.model = model

      def show(self):
          for r in self.model.results:
              print(r, self.model.results[r])
          

  class FizzBuzzController:
      def __init__(self, model, view):
          self.model = model
          self.model.add_observer(self)
          self.view = view

      def add_value_to_model(self, new_val):
          self.model.add_value(new_val)

      def notify_view(self):
          self.view.model_changed()

      def model_changed(self, added_value):
          print("[controller] model changed. Added", added_value)

      def show_view(self):
          self.view.show()

  def main():
      # creating and connecting model, view, and controller
      model = FizzBuzzModel()
      view = FizzBuzzView(model)
      controller = FizzBuzzController(model, view)

      print("# Adding values via controller to model")
      for i in range(20):
          controller.add_value_to_model(i)

      print("# Showing view of the model via controller")
      controller.show_view()

      
  main()
#+END_SRC

#+RESULTS[664a5e432edf78896d2c97903b051e0e9444c5c3]:
#+begin_example
# Adding values via controller to model
[controller] model changed. Added 0
[controller] model changed. Added 1
[controller] model changed. Added 2
[controller] model changed. Added 3
[controller] model changed. Added 4
[controller] model changed. Added 5
[controller] model changed. Added 6
[controller] model changed. Added 7
[controller] model changed. Added 8
[controller] model changed. Added 9
[controller] model changed. Added 10
[controller] model changed. Added 11
[controller] model changed. Added 12
[controller] model changed. Added 13
[controller] model changed. Added 14
[controller] model changed. Added 15
[controller] model changed. Added 16
[controller] model changed. Added 17
[controller] model changed. Added 18
[controller] model changed. Added 19
# Showing view of the model via controller
0 fizzbuzz
1 1
2 2
3 fizz
4 4
5 buzz
6 fizz
7 7
8 8
9 fizz
10 buzz
11 11
12 fizz
13 13
14 14
15 fizzbuzz
16 16
17 17
18 fizz
19 19
#+end_example

* Als Spiel (mit pygame)

=pygame= (http://pygame.org/) kann mit =pip= installiert werden.

#+BEGIN_SRC sh :results output
pip install pygame
#+END_SRC

#+RESULTS:
: Requirement already satisfied (use --upgrade to upgrade): pygame in ./fizzbuzz-ve/lib/python3.5/site-packages

file:doc/fizzbuzz_pygame.png
file:doc/ball.gif

Bei dem folgenden Beispiel hüpft ein Ball über den Bildschirm. Bei
jedem Mausklick auf den Ball wird eine Zahl, "fizz", "buzz" oder
"fizzbuzz" auf dem Ball angezeigt.

file:doc/fizzbuzz_game.svg

#+BEGIN_SRC python -n
  import sys, pygame

  class Ball(pygame.sprite.Sprite):
      def __init__(self, screen_width, screen_height):
          super().__init__()
          self.image = pygame.image.load("doc/ball.gif")
          self.rect = self.image.get_rect()
          self.speed = [2, 2] # speed in x and y direction
          self.screen_width = screen_width
          self.screen_height = screen_height

      def update(self):
          """Update called by the update of the Group method."""
          self.rect = self.rect.move(self.speed)
          if self.rect.left < 0 or self.rect.right > self.screen_width:
              self.speed[0] = -self.speed[0]
          if self.rect.top < 0 or self.rect.bottom > self.screen_height:
              self.speed[1] = -self.speed[1]

      def is_clicked(self):
          """Check whether this Ball has been clicked."""
          x,y = pygame.mouse.get_pos()
          # Coordinate system starts with (0,0) at top left
          return (self.rect.left < x < self.rect.right and
                  self.rect.top < y < self.rect.bottom)


  class FizzBuzzGame:
      def __init__(self, width, height):
          pygame.init()

          self.width, self.height = width, height
          self.screen = pygame.display.set_mode((width, height))

          self.ball = Ball(width, height)
          self.font = pygame.font.SysFont("Arial", 16)

      def fizzbuzz(self, n):
          if n % 3 == 0 and n % 5 == 0:
              return "fizzbuzz"
          elif n % 3 == 0:
              return "fizz"
          elif n % 5 == 0:
              return "buzz"
          else:
              return n

      def start_game_loop(self):
          clock = pygame.time.Clock()
          # group all sprites (here only one)
          allsprites = pygame.sprite.Group((self.ball))
          number, fb_result = 1, 1

          while True:
              clock.tick(60) # limit runtime to 60 Frames/Second

              # handle events
              for event in pygame.event.get():
                  ## handle events ##
                  if event.type == pygame.QUIT:
                      sys.exit()
                  elif event.type == pygame.MOUSEBUTTONDOWN and self.ball.is_clicked():
                      number += 1                    
                      fb_result = self.fizzbuzz(number)

              # update all Sprites
              allsprites.update()

              # draw the screen: background, sprites, text
              self.screen.fill((0,0,0))
              # for each sprite in the group draw/blit the image into a rect
              allsprites.draw(self.screen)
              # draw text on top
              fontsurf = self.font.render(str(fb_result), False, (0,255,0))
              self.screen.blit(fontsurf, self.ball.rect)                
              # flip the buffer
              pygame.display.flip()


  game = FizzBuzzGame(320, 240)
  game.start_game_loop()

#+END_SRC

#+RESULTS:

Weitere Informationen gibt es in einem [[http://pygame.org/docs/tut/PygameIntro.html][Tutorial]].

* In einem docker Container

Zunächst muss docker (https://www.docker.com/) installiert werden.

#+BEGIN_SRC sh
sudo apt-get install docker.io
#+END_SRC

Damit der lokale User auf den Dienst zugreifen kann, muss er häufig in
einer speziellen Gruppe =docker= sein.

#+BEGIN_SRC sh
sudo usermod -aG docker mein_username
#+END_SRC

Nun erstellen wir eine Datei =Dockerfile=, aus der das docker Image gebaut
werden kann.

#+INCLUDE: "Dockerfile" src sh

Der Container kann mit diesem Script nun gebaut werden. Dafür muss man
im gleichen Verzeichnis sein, in dem sich die Dateien =Dockerfile= und
=fizzbuzz_docker.py= befinden.

#+BEGIN_SRC sh :results output :exports both :cache yes
docker build -t fizzbuzz .
#+END_SRC

#+RESULTS[0cda47d0538da86654e481f7c955fa27d02111d8]:
#+begin_example
Sending build context to Docker daemon 557.1 kB
Sending build context to Docker daemon 1.114 MB
Sending build context to Docker daemon 1.671 MB
Sending build context to Docker daemon 2.228 MB
Sending build context to Docker daemon 2.785 MB
Sending build context to Docker daemon 3.342 MB
Sending build context to Docker daemon 3.899 MB
Sending build context to Docker daemon 4.456 MB
Sending build context to Docker daemon 5.014 MB
Sending build context to Docker daemon 5.571 MB
Sending build context to Docker daemon 6.128 MB
Sending build context to Docker daemon 6.685 MB
Sending build context to Docker daemon 7.242 MB
Sending build context to Docker daemon 7.799 MB
Sending build context to Docker daemon 8.356 MB
Sending build context to Docker daemon 8.913 MB
Sending build context to Docker daemon  9.47 MB
Sending build context to Docker daemon 10.03 MB
Sending build context to Docker daemon 10.58 MB
Sending build context to Docker daemon 11.14 MB
Sending build context to Docker daemon  11.7 MB
Sending build context to Docker daemon 12.26 MB
Sending build context to Docker daemon 12.81 MB
Sending build context to Docker daemon 13.37 MB
Sending build context to Docker daemon 13.93 MB
Sending build context to Docker daemon 14.48 MB
Sending build context to Docker daemon 15.04 MB
Sending build context to Docker daemon  15.6 MB
Sending build context to Docker daemon 16.15 MB
Sending build context to Docker daemon 16.71 MB
Sending build context to Docker daemon 17.27 MB
Sending build context to Docker daemon 17.83 MB
Sending build context to Docker daemon 18.38 MB
Sending build context to Docker daemon 18.94 MB
Sending build context to Docker daemon  19.5 MB
Sending build context to Docker daemon 20.05 MB
Sending build context to Docker daemon 20.61 MB
Sending build context to Docker daemon 21.17 MB
Sending build context to Docker daemon 21.73 MB
Sending build context to Docker daemon 22.28 MB
Sending build context to Docker daemon 22.84 MB
Sending build context to Docker daemon  23.4 MB
Sending build context to Docker daemon 23.95 MB
Sending build context to Docker daemon 24.51 MB
Sending build context to Docker daemon 25.07 MB
Sending build context to Docker daemon 25.62 MB
Sending build context to Docker daemon 26.18 MB
Sending build context to Docker daemon 26.74 MB
Sending build context to Docker daemon  27.3 MB
Sending build context to Docker daemon 27.85 MB
Sending build context to Docker daemon 28.41 MB
Sending build context to Docker daemon 28.97 MB
Sending build context to Docker daemon 29.52 MB
Sending build context to Docker daemon 30.08 MB
Sending build context to Docker daemon 30.64 MB
Sending build context to Docker daemon  31.2 MB
Sending build context to Docker daemon 31.75 MB
Sending build context to Docker daemon 32.31 MB
Sending build context to Docker daemon 32.87 MB
Sending build context to Docker daemon 33.42 MB
Sending build context to Docker daemon 33.98 MB
Sending build context to Docker daemon 34.54 MB
Sending build context to Docker daemon 35.09 MB
Sending build context to Docker daemon 35.65 MB
Sending build context to Docker daemon 36.21 MB
Sending build context to Docker daemon 36.77 MB
Sending build context to Docker daemon 37.32 MB
Sending build context to Docker daemon 37.88 MB
Sending build context to Docker daemon 38.44 MB
Sending build context to Docker daemon 38.99 MB
Sending build context to Docker daemon 39.55 MB
Sending build context to Docker daemon 40.11 MB
Sending build context to Docker daemon 40.67 MB
Sending build context to Docker daemon 41.22 MB
Sending build context to Docker daemon 41.48 MB

Step 1 : FROM alpine
 ---> 4a415e366388
Step 2 : RUN apk add --no-cache python3
 ---> Using cache
 ---> 515104198264
Step 3 : COPY fizzbuzz_docker.py /
 ---> 11088b4c74df
Removing intermediate container 7e3eda2412a3
Step 4 : CMD python3 /fizzbuzz_docker.py 20
 ---> Running in b83807219cdc
 ---> 45468e2e8f88
Removing intermediate container b83807219cdc
Successfully built 45468e2e8f88
#+end_example

Die in dem Dockerfile referenzierte Datei =fizzbuzz_docker.py= hat
folgenden Inhalt.

#+INCLUDE: "fizzbuzz_docker.py" src python -n

Wie prüfen, ob das Containerimage korrekt angelegt wurde.

#+BEGIN_SRC sh :results output :exports both :cache yes
docker images fizzbuzz
#+END_SRC

#+RESULTS[4fa59ed6dc72ff6a0c6c829d3dbf640aac7378b3]:
: REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
: fizzbuzz            latest              cf7d486f6a37        22 hours ago        60.58 MB

Nun kann der Container gestartet werden. Mit der Option =--rm= wird
der Container nach Beendigung der Ausführung direkt gelöscht.
Gewöhnlich sollen Container ja länger laufen und einen Dienst
bereitstellen. Das oben erstellte Image bleibt jedoch erhalten.

#+BEGIN_SRC sh :results output :exports both :cache yes
docker run --rm fizzbuzz
#+END_SRC

#+RESULTS[fcb1f9da925c411a5992e387fb529eb9f5c90958]:
#+begin_example
[using command line parameter]
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

Es können auch Parameter direkt übergeben werden.

#+BEGIN_SRC sh :results output :results output :exports both :cache yes
docker run --rm fizzbuzz /usr/bin/python3 /fizzbuzz_docker.py 10
#+END_SRC

#+RESULTS[14201e0dc02dabdf42ea0c0abb9b53171075c412]:
#+begin_example
[using command line parameter]
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
#+end_example

Nun übergeben wir keinen Parameter.

#+BEGIN_SRC sh :results output :results output :exports both :cache yes
docker run --rm fizzbuzz /usr/bin/python3 /fizzbuzz_docker.py
#+END_SRC

#+RESULTS[99e033961af6aa4e11363a090019bb04ed2a1556]:
#+begin_example
[using default value as parameter]
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
#+end_example

Auch eine Umgebungsvariable kann mit der Option =-e <VARIABLE>=<WERT>=
an den Container übergeben werden.

#+BEGIN_SRC sh :results output :exports both :cache yes
docker run --rm -e FIZZBUZZ=8 fizzbuzz
#+END_SRC

#+RESULTS[645de4e802d5e3f18cbbc60c57f82201acab31eb]:
: [using environment variable as parameter]
: fizzbuzz
: 1
: 2
: fizz
: 4
: buzz
: fizz
: 7

Wenn das Image nicht mehr benötigt wird, kann es wieder gelöscht
werden.

#+BEGIN_SRC sh :results output :exports both :cache yes
docker rmi fizzbuzz
#+END_SRC

#+RESULTS[365b7635c6c590b1263ffcf4f467075c36903023]:
: Untagged: fizzbuzz:latest
: Deleted: sha256:6fe92919b9068f38cf7e4a4f5cd9fd0d6fc4c69f280e3c82668e4cd6d0edc539
: Deleted: sha256:5ddf7803d3884e39ea8517e3fb1a2200fdf9182726dcd06c1336938e0ddb89ae
: Deleted: sha256:26d94ce55f7cd7c4d84b4bdb6d64d114cac80b07b775e7420ddc81ab8d471ac2

** TODO bei dockerhub hochladen   :noexport:

Ein fertiger Container kann bei dockerhub.com hochgeladen werden.
* Mit Fehlerbehandlung

[[https://docs.python.org/3/tutorial/errors.html][Errors und Exceptions]] in Python.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  class FizzBuzzException(Exception):
      """An exception for the FizzBuzz game."""
      def __init__(self, errormessage, val):
          """Create the exception with the given message and the problematic value."""
          self.errormessage = errormessage
          self.value = val

  class FizzBuzzSpiel:
      def fizzbuzz(self, i):
          if i < 0:
              # Raise an Exception and stop execution if the parameter is negative
              raise FizzBuzzException("Das Argument muss positiv sein!", i)
          
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)

              
  fb = FizzBuzzSpiel()
  for i in range(-5, 5):

      # trying to run the code
      try:
          print("Probiere", i)
          fb.fizzbuzz(i)
          
      except FizzBuzzException as ex:
          # Whenever an exception is raised, jump to this code block
          print("[Fehler]", ex.errormessage, ex.value)
#+END_SRC

#+RESULTS[01eda6d61d11851d167f3216d67b5b8861a6c668]:
#+begin_example
Probiere -5
[Fehler] Das Argument muss positiv sein! -5
Probiere -4
[Fehler] Das Argument muss positiv sein! -4
Probiere -3
[Fehler] Das Argument muss positiv sein! -3
Probiere -2
[Fehler] Das Argument muss positiv sein! -2
Probiere -1
[Fehler] Das Argument muss positiv sein! -1
Probiere 0
fizzbuzz
Probiere 1
1
Probiere 2
2
Probiere 3
fizz
Probiere 4
4
#+end_example

* Mit einem neuronalen Netzwerk

Der Artikel [[http://natureofcode.com/book/chapter-10-neural-networks/][Neural Networks]] beschreibt die Funktionsweise eines
neuronalen Netzwerkes. Das folgende neuronale Netz, soll das
fizzbuzz-Problem lösen.

file:doc/fizzbuzz_neuralnet.svg

Hierfür wird ein Netwerk aus 23 Perceptrons erstellt: 20 davon bilden
die Zahlen 0-19 ab, die restlichen drei die Fällen =fizz=, =buzz= und
=fizzbuzz=. Ein Input =i= wird kodiert, indem die Zahl am Eingang =i=
auf 1, an allen anderen Eingängen auf -1 gelegt wird. Zum Schluss wird
das Perceptron mit dem höchsten Wert gewählt. Das Netzwerk wird in
immer mehr Trainingsrunden verbessert.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import random

  class Perceptron:
      def __init__(self, num_inputs):
          self.c = 0.01 # coefficient that determines learning speed.

          # random values weights in [-1;+1]
          self.weights = [random.randint(-100,100)/100 for i in range(num_inputs)]
          
      def feedforward(self, inputs):
          """Ask a trained perceptron for output on given input."""
          assert len(self.weights) == len(inputs)

          sum = 0        
          for i in range(len(self.weights)):
              sum += inputs[i] * self.weights[i]

          return self.activate(sum)

      def activate(self, sum):
          """Activation function determines when the perceptron fires - if output is positive."""
          if sum > 0:
              return +1
          else:
              return -1

      def train(self, inputs, desired):
          """Train for inputs and desired result."""
          assert len(inputs) == len(self.weights)
          
          guess = self.feedforward(inputs)
          error = desired - guess

          for i in range(len(self.weights)):
              self.weights[i] += self.c * error * inputs[i]

              
  class NeuralNetwork:
      def __init__(self, num_inputs, num_outputs):
          """Create a neural network of perceptrons. 

          num_inputs denotes the number of inputs per Perceptron, while
          num_outputs denotes the number of perceptrons and therefore
          the number of outputs.
          """
          self.ptrons = []
          for i in range(num_outputs):
              self.ptrons.append(Perceptron(num_inputs))            

      def train(self, inputs, desired_outputs):
          """Train the network by training all perceptrons in it."""
          assert len(inputs) == self.num_inputs()
          assert len(desired_outputs) == self.num_outputs()
          
          for pi in range(len(self.ptrons)):
              self.ptrons[pi].train(inputs, desired_outputs[pi])

      def ask(self, inputs):
          """Ask the network for an answer. It will return the index and value
          of the perceptron with the maximum value.
          """
          answers = []
          for p in self.ptrons:
              a = p.feedforward(inputs)
              answers.append(a)

          # determine maximum output value
          maxval = [0, answers[0]]
          for (i,a) in enumerate(answers):
              if a > maxval[1]:
                  maxval = [i, a]

          return maxval
      
      def num_inputs(self):
          assert len(self.ptrons) > 0
          
          return len(self.ptrons[0].weights)

      def num_outputs(self):
          return len(self.ptrons)


  class FizzbuzzNetwork(NeuralNetwork):
      def __init__(self, numbers):
          # adding 3 outputs for fizz, buzz and fizzbuzz
          super().__init__(numbers, numbers+3)
          
          self.numbers = numbers
          self.fizz = numbers
          self.buzz = numbers + 1
          self.fizzbuzz = numbers + 2
      
      def train_rounds(self, training_rounds):
          for _ in range(training_rounds):
              for i in range(self.numbers):
                  inputs = self.encode_input(i)

                  # answer a is 1 for the right perceptron, -1 otherwise
                  outputs = [-1] * (self.numbers + 3)
                  if i%3==0 and i%5==0:                
                      outputs[self.fizzbuzz] = 1
                  elif i%3==0:
                      outputs[self.fizz] = 1
                  elif i%5==0:
                      outputs[self.buzz] = 1
                  else:
                      outputs[i] = 1

                  self.train(inputs, outputs)

      def encode_input(self, num):
          assert num < self.numbers
          
          inputs = [0] * self.numbers
          inputs[num] = 1
          return inputs

      def ask(self, inputs):
          idx, value = super().ask(inputs)
          
          if idx == self.fizz:
              idx = "fizz"
          elif idx == self.buzz:
              idx = "buzz"
          elif idx == self.fizzbuzz:
              idx = "fizzbuzz"
              
          return idx, value

      
  def fizzbuzz_nn():
      numbers = 20    

      # training the network several times
      for rounds in [10, 45, 100]:
          print("training", rounds, "rounds")
          
          nn = FizzbuzzNetwork(numbers)
          nn.train_rounds(rounds)

          # asking the trained network
          for i in range(numbers):
              inputs = nn.encode_input(i)        
              idx, answer = nn.ask(inputs)
              print(i, idx)
   

  fizzbuzz_nn()

#+END_SRC

#+RESULTS[98215b493c59ca95f863fcd8f9767949024514ea]:
#+begin_example
training 10 rounds
0 0
1 0
2 5
3 2
4 0
5 4
6 3
7 0
8 1
9 8
10 0
11 2
12 4
13 0
14 1
15 0
16 0
17 0
18 0
19 3
training 45 rounds
0 1
1 16
2 1
3 fizz
4 4
5 7
6 2
7 0
8 8
9 6
10 buzz
11 8
12 fizz
13 7
14 14
15 fizzbuzz
16 16
17 16
18 1
19 19
training 100 rounds
0 fizzbuzz
1 1
2 2
3 fizz
4 4
5 buzz
6 fizz
7 7
8 8
9 fizz
10 buzz
11 11
12 fizz
13 13
14 14
15 fizzbuzz
16 16
17 17
18 fizz
19 19
#+end_example

* Mit logging in ein logfile

Logging wird in Python über das gleichnamige Modul [[https://docs.python.org/3/library/logging.html][logging]] realisiert.

#+BEGIN_SRC python -n :results output :cache yes
  import logging

  class FizzbuzzLogged:
      def __init__(self):        
          logging.info("Logger initialized!")

      def fizzbuzz(self, i):
          if i < 0:
              logging.warn("ignoring %s", i)
              return

          logging.info("value %s", i)
          if i % 3 == 0 and i % 5 == 0:
              logging.info("fizzbuzz")
          elif i % 3 == 0:
              logging.info("fizz")
          elif i % 5 == 0:
              logging.info("buzz")
          else:
              logging.info(i)


  if __name__ == "__main__":
      # configuring logging: using log-level DEBUG and above
      logging.basicConfig(filename="fizzbuzz.log", level=logging.DEBUG)
      
      fb = FizzbuzzLogged()
      for i in range(-5, 20):
          fb.fizzbuzz(i)
      

#+END_SRC

#+RESULTS[71709335377a5c0f96c611edeecf8eeb5e9b02a7]:

Das Programm schreibt Ausgaben nun in ein Logfile:

#+INCLUDE: fizzbuzz.log src sh

* Mit einem Profiler

Python-Programme können mit dem Paket [[https://docs.python.org/3/library/profile.html][profile]] auf ihre Geschwindigkeit
untersucht werden.

#+BEGIN_SRC python -n :results output :exports both :cache yes
  import cProfile

  def fizzbuzz_method(n):
      for i in range(n):
          if i % 3 == 0 and i % 5 == 0:
              print("fizzbuzz")
          elif i % 3 == 0:
              print("fizz")
          elif i % 5 == 0:
              print("buzz")
          else:
              print(i)

  if __name__ == "__main__":
      # running the profiler for the given method invocation
      cProfile.run("fizzbuzz_method(20)")

#+END_SRC

#+RESULTS[cb062b106f92a10e5375f63ea3bc894f2bf89c04]:
#+begin_example
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
         24 function calls in 0.000 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 <stdin>:3(fizzbuzz_method)
        1    0.000    0.000    0.000    0.000 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
       20    0.000    0.000    0.000    0.000 {built-in method builtins.print}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}


#+end_example

Das Ergebnis fasst die Zeiten für jeden Funktionsaufruf zusammen. 

- =ncalls= ist die Anzahl der Aufrufe.
- =totime= ist die Gesamtzeit in der Methode (ohne Aufrufe von
  Unterfunktionen).
- =percall= ist der Quotient aus =totime= und =ncalls=.
- =cumtime= ist die aufsummierte Zeit, die insgesamt von der Funktion
  benötigt wurde.
- =percall= ist der Quotient aus =cumtime= und der Aufrufe von
  primitiven Funktionen.

